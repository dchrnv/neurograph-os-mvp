# CDNA v2.1 — Спецификация когнитивной ДНК

**Версия:** 2.1.0  
**Дата:** 2025-10-26  
**Статус:** ФИНАЛЬНАЯ — Готова к реализации  
**Размер:** 384 байта (6 кеш-линий)

---

## Содержание

1. [Обзор](#обзор)
2. [Архитектура](#архитектура)
3. [Карта памяти](#карта-памяти)
4. [Спецификации блоков](#спецификации-блоков)
   - [Блок 1: Заголовок](#блок-1-заголовок-64-байта)
   - [Блок 2: Физика сетки](#блок-2-константы-физики-сетки-128-байт)
   - [Блок 3: Топология графа](#блок-3-правила-топологии-графа-64-байта)
   - [Блок 4: Свойства токенов](#блок-4-базовые-свойства-токенов-32-байта)
   - [Блок 5: Ограничения связей](#блок-5-ограничения-связей-64-байта)
   - [Блок 6: Эволюция и подписка](#блок-6-эволюция-и-подписка-32-байта)
5. [Система событий](#система-событий)
6. [Управление подписками](#управление-подписками)
7. [История версий](#история-версий)
8. [Правила валидации](#правила-валидации)
9. [Система профилей](#система-профилей)
10. [Примеры использования](#примеры-использования)

---

## Обзор

### Что такое CDNA?

**CDNA (Cognitive DNA — Когнитивная ДНК)** — это конституционный фреймворк системы NeuroGraph OS. Она определяет:

- **Физику 8-мерного семантического пространства** — как измеряются и взвешиваются измерения
- **Правила топологии графа** — разрешённые типы связей, лимиты степеней узлов, структурные ограничения
- **Свойства токенов** — базовые характеристики информационных единиц
- **Ограничения связей** — параметры жёсткости, связности, затухания
- **Правила эволюции** — параметры мутации, кроссовера, отбора
- **Система подписки** — как модули получают и применяют изменения конфигурации

### Ключевые принципы

1. **CDNA — это ЗАКОН** — Только пользователь может изменять её (никакой автономности)
2. **Модель подписки (Pub/Sub)** — Модули подписываются на изменения, не опрашивают CDNA постоянно
3. **Система карантина** — Новые конфигурации тестируются в изоляции перед продакшеном
4. **История версий** — Возможность отката к любой предыдущей стабильной версии
5. **На основе профилей** — Предустановленные конфигурации (Исследователь, Аналитик, Творческий)

### Цели дизайна

- ✅ **384 байта** — Ровно 6 кеш-линий CPU
- ✅ **Загрузка без копирования** — Прямое отображение в память
- ✅ **Детерминированная валидация** — У всех параметров чёткие границы
- ✅ **Совместимость вперёд** — Поддержка диапазона версий
- ✅ **Атомарные обновления** — Изменения конфигурации "всё или ничего"

---

## Архитектура

```
┌─────────────────────────────────────────────────────────────┐
│                      CDNA v2.1                              │
│                   (384 байта всего)                         │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  ┌───────────────────────────────────────────────────┐     │
│  │ Блок 1: ЗАГОЛОВОК (64 байта)                     │     │
│  │ • Magic number, версия, временные метки          │     │
│  │ • ID профиля, состояние профиля                  │     │
│  │ • Флаги, контрольная сумма                       │     │
│  └───────────────────────────────────────────────────┘     │
│                                                             │
│  ┌───────────────────────────────────────────────────┐     │
│  │ Блок 2: ФИЗИКА СЕТКИ (128 байт)                  │     │
│  │ • 8 измерений × семантические ID                 │     │
│  │ • 8 измерений × флаги                            │     │
│  │ • 8 измерений × коэффициенты масштаба            │     │
│  └───────────────────────────────────────────────────┘     │
│                                                             │
│  ┌───────────────────────────────────────────────────┐     │
│  │ Блок 3: ТОПОЛОГИЯ ГРАФА (64 байта)               │     │
│  │ • Разрешённые типы связей (битовая маска)        │     │
│  │ • Лимиты степеней узлов                          │     │
│  │ • Пороги весов                                   │     │
│  │ • Флаги топологии                                │     │
│  └───────────────────────────────────────────────────┘     │
│                                                             │
│  ┌───────────────────────────────────────────────────┐     │
│  │ Блок 4: СВОЙСТВА ТОКЕНОВ (32 байта)              │     │
│  │ • Диапазон весов                                 │     │
│  │ • Диапазон радиуса поля                          │     │
│  │ • Флаги токенов                                  │     │
│  └───────────────────────────────────────────────────┘     │
│                                                             │
│  ┌───────────────────────────────────────────────────┐     │
│  │ Блок 5: ОГРАНИЧЕНИЯ СВЯЗЕЙ (64 байта)            │     │
│  │ • Диапазон жёсткости                             │     │
│  │ • Сила связности                                 │     │
│  │ • Скорость затухания                             │     │
│  │ • Уровни силы                                    │     │
│  └───────────────────────────────────────────────────┘     │
│                                                             │
│  ┌───────────────────────────────────────────────────┐     │
│  │ Блок 6: ЭВОЛЮЦИЯ И ПОДПИСКА (32 байта)           │     │
│  │ • Скорости мутации/кроссовера                    │     │
│  │ • Настройки карантина                            │     │
│  │ • Пороги валидации                               │     │
│  │ • Флаги подписки                                 │     │
│  └───────────────────────────────────────────────────┘     │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

---

## Карта памяти

```
╔═══════════════════════════════════════════════════════════╗
║                CDNA v2.1 (384 байта)                      ║
║              6 кеш-линий (64 × 6)                         ║
╠═══════════════════════════════════════════════════════════╣
║  Блок 1: ЗАГОЛОВОК (64 байта)                            ║
║           Метаданные, версия, контрольная сумма           ║
║           Состояние профиля                               ║
╠═══════════════════════════════════════════════════════════╣
║  Блок 2: КОНСТАНТЫ ФИЗИКИ СЕТКИ (128 байт)               ║
║           Семантические ID, флаги, масштабы измерений     ║
╠═══════════════════════════════════════════════════════════╣
║  Блок 3: ПРАВИЛА ТОПОЛОГИИ ГРАФА (64 байта)              ║
║           Типы связей, лимиты, флаги топологии            ║
╠═══════════════════════════════════════════════════════════╣
║  Блок 4: БАЗОВЫЕ СВОЙСТВА ТОКЕНОВ (32 байта)             ║
║           Диапазоны весов, свойства полей, флаги          ║
╠═══════════════════════════════════════════════════════════╣
║  Блок 5: ОГРАНИЧЕНИЯ СВЯЗЕЙ (64 байта)                   ║
║           Жёсткость, связность, затухание, уровни сил     ║
╠═══════════════════════════════════════════════════════════╣
║  Блок 6: ЭВОЛЮЦИЯ И ПОДПИСКА (32 байта)                  ║
║           Мутации, карантин, валидация, события           ║
╚═══════════════════════════════════════════════════════════╝

Карта памяти:
Смещение  Блок                       Размер
─────────────────────────────────────────────
0-63      Заголовок                  64 байта
64-191    Физика сетки               128 байт
192-255   Топология графа            64 байта
256-287   Свойства токенов           32 байта
288-351   Ограничения связей         64 байта
352-383   Эволюция и подписка        32 байта
─────────────────────────────────────────────
Итого:                               384 байта = 6 кеш-линий
```

---

## Спецификации блоков

### Блок 1: ЗАГОЛОВОК (64 байта)

**Смещение: 0-63**

```rust
#[repr(C, packed)]
pub struct CDNAHeader {
    // ═══════════════════════════════════════════════════════
    // ИДЕНТИФИКАЦИЯ (16 байт)
    // ═══════════════════════════════════════════════════════
    
    // Смещение 0-7: Magic number и версия
    magic: [u8; 8],                  // "NGCDNA21" (8 байт ASCII)
                                     // Идентифицирует формат файла и мажорную версию
    
    // Смещение 8-11: Детали версии
    version_major: u16,              // 2 (ломающие изменения)
    version_minor: u16,              // 1 (новые функции, обратно совместимые)
    
    // Смещение 12-13: Информация о формате
    version_patch: u8,               // 0 (исправления багов)
    endianness: u8,                  // 0x02 = little-endian, 0x01 = big-endian
    
    // Смещение 14-15: Диапазон совместимости
    min_compatible_major: u8,        // Минимальная совместимая мажорная версия
    max_compatible_major: u8,        // Максимальная совместимая мажорная версия
    
    // ═══════════════════════════════════════════════════════
    // ВРЕМЕННЫЕ МЕТАДАННЫЕ (16 байт)
    // ═══════════════════════════════════════════════════════
    
    // Смещение 16-23: Временная метка создания
    created_timestamp: u64,          // Unix timestamp в секундах
                                     // Когда эта CDNA была создана
    
    // Смещение 24-31: Временная метка модификации
    modified_timestamp: u64,         // Время последней модификации
                                     // Обновляется при изменении параметров CDNA
    
    // ═══════════════════════════════════════════════════════
    // ИНФОРМАЦИЯ О ПРОФИЛЕ (12 байт)
    // ═══════════════════════════════════════════════════════
    
    // Смещение 32-35: Идентификация профиля
    profile_id: u32,                 // Уникальный идентификатор профиля
                                     // Примеры:
                                     // 0x00000001 = default (по умолчанию)
                                     // 0x00000100 = explorer (исследователь)
                                     // 0x00000200 = analyzer (аналитик)
                                     // 0x00000300 = creative (творческий)
    
    // Смещение 36-39: Тип профиля (enum)
    profile_type: u32,               // Категория профиля
                                     // 0x01 = EXPLORER (исследователь)
                                     // 0x02 = ANALYZER (аналитик)
                                     // 0x03 = CREATIVE (творческий)
                                     // 0xFF = CUSTOM (пользовательский)
    
    // Смещение 40-43: Состояние профиля (НОВОЕ в v2.1)
    profile_state: u32,              // Текущее состояние этой CDNA
                                     // 0x00 = STABLE (стабильная, готова к продакшену)
                                     // 0x01 = QUARANTINE (карантин, тестируется)
                                     // 0x02 = PROPOSED (предложена, не применена)
                                     // 0x03 = DEPRECATED (устарела, старая версия)
                                     // 0xFF = FAILED (провалила валидацию)
    
    // ═══════════════════════════════════════════════════════
    // ФЛАГИ И РАЗМЕР (8 байт)
    // ═══════════════════════════════════════════════════════
    
    // Смещение 44-47: Флаги CDNA
    cdna_flags: u32,                 // Поведенческие флаги:
                                     // Бит 0:  IMMUTABLE (неизменяемая)
                                     // Бит 1:  VALIDATED (прошла все проверки)
                                     // Бит 2:  SEALED (криптографически запечатана)
                                     // Бит 3:  REQUIRE_SIGNATURE (требует подпись для загрузки)
                                     // Бит 4:  EXPERIMENTAL (нестабильный профиль)
                                     // Бит 5:  PRODUCTION_READY (готова к продакшену)
                                     // Бит 6:  DEBUG_MODE (подробная валидация)
                                     // Бит 7:  STRICT_MODE (падать на предупреждениях)
                                     // Бит 8-31: Зарезервировано
    
    // Смещение 48-51: Проверка размера данных
    total_size: u32,                 // Должно всегда быть 384
                                     // Используется для проверки целостности файла
    
    // ═══════════════════════════════════════════════════════
    // ПРОВЕРКА ЦЕЛОСТНОСТИ (16 байт) — ОБНОВЛЕНО в v2.1
    // ═══════════════════════════════════════════════════════
    
    // Смещение 52-63: Контрольная сумма (первые 16 байт SHA-256)
    data_checksum: [u8; 16],         // Первые 16 байт хеша SHA-256
                                     // Покрывает смещения 64-383 (320 байт)
                                     // Уменьшена с 32 до 16 байт для экономии места
                                     // 128-битная контрольная сумма достаточна для целостности
}

Итого: 64 байта
```

#### Magic Number (магическое число)

```
"NGCDNA21"
  ││││││└└─ Версия (21 = v2.1)
  │││└└└─── DNA (ДНК)
  ││└────── Cognitive (когнитивная)
  │└─────── NeuroGraph
  └──────── Префикс пространства имён
```

#### Система версионирования

```
Семантическое версионирование: MAJOR.MINOR.PATCH

MAJOR (u16):
    Ломающие изменения, несовместимые с предыдущими версиями
    Пример: v1.x не может загрузить v2.x

MINOR (u16):
    Новые функции, обратно совместимые
    Пример: v2.1 может понимать файлы v2.0

PATCH (u8):
    Только исправления багов
    Всегда совместима в пределах одной MAJOR.MINOR
```

#### Состояния профиля

```
STABLE (0x00):
    • Готовая к продакшену конфигурация
    • Прошла все проверки валидации
    • Сейчас используется системой
    
QUARANTINE (0x01):
    • Тестируется новая конфигурация
    • Метрики здоровья отслеживаются
    • Ещё не переведена в продакшен
    
PROPOSED (0x02):
    • Пользователь предложил изменение
    • Ещё не применена к системе
    • Ожидает валидации
    
DEPRECATED (0x03):
    • Старая версия, больше не рекомендуется
    • Хранится для исторической справки
    • Может использоваться для отката
    
FAILED (0xFF):
    • Провалила проверки валидации
    • Не может быть применена к системе
    • Доступна отладочная информация
```

---

### Блок 2: КОНСТАНТЫ ФИЗИКИ СЕТКИ (128 байт)

**Смещение: 64-191**

```rust
#[repr(C, packed)]
pub struct GridPhysicsConstants {
    // ═══════════════════════════════════════════════════════
    // ИДЕНТИФИКАТОРЫ СЕМАНТИЧЕСКОГО ПРОСТРАНСТВА (32 байта)
    // ═══════════════════════════════════════════════════════
    
    // Смещение 0-31: Семантические ID измерений (8 × u32)
    dimension_semantic_id: [u32; 8], // Семантические идентификаторы для каждого измерения:
                                     // [0] PHYSICAL (физическое)    = 0x50485953
                                     // [1] SENSORY (сенсорное)      = 0x53454E53
                                     // [2] MOTOR (моторное)         = 0x4D4F544F
                                     // [3] EMOTIONAL (эмоциональное)= 0x454D4F54
                                     // [4] COGNITIVE (когнитивное)  = 0x434F474E
                                     // [5] SOCIAL (социальное)      = 0x534F4349
                                     // [6] TEMPORAL (темпоральное)  = 0x54454D50
                                     // [7] ABSTRACT (абстрактное)   = 0x41425354
    
    // ═══════════════════════════════════════════════════════
    // ФЛАГИ ИЗМЕРЕНИЙ (32 байта)
    // ═══════════════════════════════════════════════════════
    
    // Смещение 32-63: Флаги измерений (8 × u32)
    dimension_flags: [u32; 8],       // Флаги для каждого измерения:
                                     // Бит 0:  ENABLED (измерение активно)
                                     // Бит 1:  WRITABLE (может быть изменено)
                                     // Бит 2:  NORMALIZED (значения нормализованы к [0,1])
                                     // Бит 3:  PERIODIC (циклично, напр., углы)
                                     // Бит 4:  LOGARITHMIC (логарифмическая шкала)
                                     // Бит 5:  SYMMETRIC (симметрично вокруг нуля)
                                     // Бит 6-31: Зарезервировано
    
    // ═══════════════════════════════════════════════════════
    // МАСШТАБЫ ИЗМЕРЕНИЙ (64 байта)
    // ═══════════════════════════════════════════════════════
    
    // Смещение 64-127: Коэффициенты масштаба (8 × f64)
    dimension_scale: [f64; 8],       // Важность/вес каждого измерения
                                     // Диапазон: 0.0 - 100.0
                                     // По умолчанию: [1.0, 1.5, 1.2, 2.0, 3.0, 2.5, 2.0, 10.0]
                                     // Большие значения = измерение более влиятельно
                                     //                    в расчётах сил
}

Итого: 128 байт
```

#### Семантические ID измерений (ASCII Hex)

```
PHYSICAL  (физическое)    = 0x50485953 = "PHYS"
SENSORY   (сенсорное)     = 0x53454E53 = "SENS"
MOTOR     (моторное)      = 0x4D4F544F = "MOTO"
EMOTIONAL (эмоциональное) = 0x454D4F54 = "EMOT"
COGNITIVE (когнитивное)   = 0x434F474E = "COGN"
SOCIAL    (социальное)    = 0x534F4349 = "SOCI"
TEMPORAL  (темпоральное)  = 0x54454D50 = "TEMP"
ABSTRACT  (абстрактное)   = 0x41425354 = "ABST"
```

#### Объяснение флагов измерений

```
ENABLED (активно):
    • Если установлен: измерение активно и используется в расчётах
    • Если сброшен: измерение игнорируется (фактически отключено)
    • Применение: временно отключать неиспользуемые измерения
    
WRITABLE (записываемо):
    • Если установлен: токены могут свободно перемещаться в этом измерении
    • Если сброшен: измерение только для чтения (фиксированные позиции)
    
NORMALIZED (нормализовано):
    • Если установлен: все значения масштабированы к диапазону [0, 1]
    • Если сброшен: используются сырые значения координат
    
PERIODIC (периодично):
    • Если установлен: измерение циклично (напр., 360° = 0°)
    • Если сброшен: измерение имеет жёсткие границы
    
LOGARITHMIC (логарифмично):
    • Если установлен: измерение использует логарифмическую шкалу
    • Если сброшен: линейная шкала
    • Применение: темпоральное измерение (события распределены по временным шкалам)
    
SYMMETRIC (симметрично):
    • Если установлен: измерение симметрично вокруг нуля [-x, +x]
    • Если сброшен: одностороннее [0, x]
```

#### Коэффициенты масштаба по умолчанию

```
Профиль: DEFAULT (по умолчанию)
    PHYSICAL:   1.0   — базовая важность
    SENSORY:    1.5   — немного более влиятельное
    MOTOR:      1.2   — физические действия
    EMOTIONAL:  2.0   — эмоции важны
    COGNITIVE:  3.0   — мышление важно
    SOCIAL:     2.5   — социальный контекст важен
    TEMPORAL:   2.0   — временные связи
    ABSTRACT:   10.0  — абстрактные концепции доминируют

Профиль: EXPLORER (исследователь, высокая вариативность)
    [1.0, 1.5, 1.2, 2.0, 3.0, 2.5, 2.0, 5.0]
    
Профиль: ANALYZER (аналитик, фокус на абстрактном)
    [1.0, 1.0, 1.0, 1.5, 10.0, 5.0, 3.0, 20.0]
    
Профиль: CREATIVE (творческий, экзотичный, Фибоначчи)
    [1.0, 2.0, 3.0, 5.0, 8.0, 13.0, 21.0, 34.0]
```

---

### Блок 3: ПРАВИЛА ТОПОЛОГИИ ГРАФА (64 байта)

**Смещение: 192-255**

```rust
#[repr(C, packed)]
pub struct GraphTopologyRules {
    // ═══════════════════════════════════════════════════════
    // ОГРАНИЧЕНИЯ ТИПОВ СВЯЗЕЙ (8 байт)
    // ═══════════════════════════════════════════════════════
    
    // Смещение 0-1: Разрешённые типы связей (битовая маска)
    allowed_connection_types: u16,   // Битовая маска разрешённых типов связей:
                                     // Бит 0:  ASSOCIATION (ассоциация)
                                     // Бит 1:  CAUSALITY (причинность)
                                     // Бит 2:  COMPOSITION (композиция)
                                     // Бит 3:  DEPENDENCY (зависимость)
                                     // Бит 4:  EQUIVALENCE (эквивалентность)
                                     // Бит 5:  HIERARCHY (иерархия)
                                     // Бит 6:  IMPLICATION (импликация)
                                     // Бит 7:  INHERITANCE (наследование)
                                     // Бит 8:  OPPOSITION (противопоставление)
                                     // Бит 9:  SEQUENCE (последовательность)
                                     // Бит 10: SIMILARITY (схожесть)
                                     // Бит 11: SPECIALIZATION (специализация)
                                     // Бит 12: TEMPORAL (временная)
                                     // Бит 13: TRANSFORMATION (трансформация)
                                     // Бит 14: CUSTOM_1 (пользовательский тип 1)
                                     // Бит 15: CUSTOM_2 (пользовательский тип 2)
    
    // Смещение 2-3: Зарезервировано
    reserved_types: u16,
    
    // Смещение 4-7: Специфичные флаги типов
    type_flags: u32,                 // Дополнительные ограничения по типам
                                     // (будущее расширение)
    
    // ═══════════════════════════════════════════════════════
    // ОГРАНИЧЕНИЯ СТЕПЕНИ (12 байт)
    // ═══════════════════════════════════════════════════════
    
    // Смещение 8-11: Максимальная степень узла
    max_node_degree: u32,            // Максимум связей на токен
                                     // Диапазон: 1 - 10000
                                     // По умолчанию: 1000
                                     // Исследователь: 500
                                     // Аналитик: 100
    
    // Смещение 12-15: Минимальная степень узла (мягкое ограничение)
    min_node_degree: u32,            // Рекомендуемый минимум связей
                                     // 0 = нет минимума (разрешить изолированные узлы)
                                     // По умолчанию: 0
    
    // Смещение 16-19: Максимальная степень на тип связи
    max_degree_per_type: u32,        // Максимум связей одного типа
                                     // 0 = без лимита
                                     // По умолчанию: 0
    
    // ═══════════════════════════════════════════════════════
    // ОГРАНИЧЕНИЯ ВЕСОВ (12 байт)
    // ═══════════════════════════════════════════════════════
    
    // Смещение 20-23: Минимальный вес связи
    min_connection_weight: f32,      // Минимальный вес для поддержания связи
                                     // Диапазон: 0.0 - 1.0
                                     // По умолчанию: 0.1
                                     // Ниже этого: связь удаляется
    
    // Смещение 24-27: Максимальный вес связи
    max_connection_weight: f32,      // Максимальный разрешённый вес
                                     // Диапазон: 0.0 - 100.0
                                     // По умолчанию: 10.0
    
    // Смещение 28-31: Порог затухания веса
    weight_decay_threshold: f32,     // Вес, ниже которого затухание ускоряется
                                     // По умолчанию: 0.3
    
    // ═══════════════════════════════════════════════════════
    // ФЛАГИ ТОПОЛОГИИ (8 байт)
    // ═══════════════════════════════════════════════════════
    
    // Смещение 32-35: Общие флаги топологии
    topology_flags: u32,             // Ограничения структуры графа:
                                     // Бит 0:  DIRECTED (рёбра имеют направление)
                                     // Бит 1:  WEIGHTED (рёбра имеют веса)
                                     // Бит 2:  ALLOW_SELF_LOOPS (разрешить петли)
                                     // Бит 3:  ALLOW_MULTI_EDGES (параллельные рёбра)
                                     // Бит 4:  REQUIRE_CONNECTED (нет изолированных узлов)
                                     // Бит 5:  ALLOW_DYNAMIC_TOPOLOGY (изменения в рантайме)
                                     // Бит 6:  ENFORCE_ACYCLIC (без циклов, DAG)
                                     // Бит 7:  BIDIRECTIONAL_SYNC (A→B подразумевает B→A)
                                     // Бит 8-31: Зарезервировано
    
    // Смещение 36-39: Флаги удаления
    pruning_flags: u32,              // Бит 0:  AUTO_PRUNE_WEAK (удалять < min_weight)
                                     // Бит 1:  AUTO_PRUNE_ISOLATED (удалять отключённые)
                                     // Бит 2:  PRUNE_ON_LOAD (очистка при запуске)
                                     // Бит 3-31: Зарезервировано
    
    // ═══════════════════════════════════════════════════════
    // ПРОСТРАНСТВЕННЫЕ ОГРАНИЧЕНИЯ (24 байта)
    // ═══════════════════════════════════════════════════════
    
    // Смещение 40-43: Максимальное расстояние связи
    max_connection_distance: f32,    // Максимальное евклидово расстояние для связей
                                     // 0.0 = без лимита
                                     // По умолчанию: 0.0 (неограниченно)
    
    // Смещение 44-47: Минимальное расстояние связи
    min_connection_distance: f32,    // Минимальное расстояние (избегать слишком близких)
                                     // По умолчанию: 0.0
    
    // Смещение 48-51: Метрика расстояния
    distance_metric: u32,            // 0 = Евклидова
                                     // 1 = Манхэттенская
                                     // 2 = Чебышёва
                                     // 3 = Минковского (p=3)
                                     // 4 = Пользовательская
    
    // Смещение 52-63: Зарезервировано для будущих пространственных ограничений
    reserved_spatial: [u32; 3],
}

Итого: 64 байта
```

#### Типы связей (16 типов)

```
ASSOCIATION (0):      Общая семантическая ассоциация
CAUSALITY (1):        Причинно-следственная связь
COMPOSITION (2):      Отношение часть-целое
DEPENDENCY (3):       Одно зависит от другого
EQUIVALENCE (4):      Семантическая эквивалентность
HIERARCHY (5):        Иерархия родитель-потомок
IMPLICATION (6):      Логическая импликация
INHERITANCE (7):      Наследование типа
OPPOSITION (8):       Семантическое противопоставление
SEQUENCE (9):         Временная/процедурная последовательность
SIMILARITY (10):      Семантическая схожесть
SPECIALIZATION (11):  Отношение специализации
TEMPORAL (12):        Временная связь
TRANSFORMATION (13):  Трансформация состояния
CUSTOM_1 (14):        Пользовательский тип 1
CUSTOM_2 (15):        Пользовательский тип 2
```

#### Объяснение флагов топологии

```
DIRECTED (направленный):
    • Рёбра имеют направление (A → B ≠ B → A)
    • Важно для причинности, иерархии
    
WEIGHTED (взвешенный):
    • Рёбра имеют веса
    • Все профили включают это
    
ALLOW_SELF_LOOPS (разрешить петли):
    • Токен может соединяться сам с собой
    • Применение: рекурсивные концепции
    
ALLOW_MULTI_EDGES (разрешить множественные рёбра):
    • Несколько связей между одной парой
    • Разные типы или веса
    
REQUIRE_CONNECTED (требовать связности):
    • Нет изолированных узлов
    • Система обеспечивает связность
    
ALLOW_DYNAMIC_TOPOLOGY (динамическая топология):
    • Связи могут добавляться/удаляться в рантайме
    • По умолчанию: включено
    
ENFORCE_ACYCLIC (без циклов):
    • Нет циклов (направленный ациклический граф)
    • Применение: графы зависимостей
    
BIDIRECTIONAL_SYNC (двунаправленная синхронизация):
    • A → B автоматически создаёт B → A
    • Применение: симметричные отношения
```

---

### Блок 4: БАЗОВЫЕ СВОЙСТВА ТОКЕНОВ (32 байта)

**Смещение: 256-287**

```rust
#[repr(C, packed)]
pub struct TokenBaseProperties {
    // ═══════════════════════════════════════════════════════
    // ОГРАНИЧЕНИЯ ВЕСА (8 байт)
    // ═══════════════════════════════════════════════════════
    
    // Смещение 0-3: Минимальный вес токена
    min_weight: f32,                 // Минимальная масса/важность
                                     // Диапазон: 0.0 - 1000.0
                                     // По умолчанию: 0.1
                                     // Ниже этого: токен может быть удалён сборщиком мусора
    
    // Смещение 4-7: Максимальный вес токена
    max_weight: f32,                 // Максимальная масса/важность
                                     // Диапазон: 0.0 - 10000.0
                                     // По умолчанию: 1000.0
    
    // ═══════════════════════════════════════════════════════
    // СВОЙСТВА ПОЛЯ (8 байт)
    // ═══════════════════════════════════════════════════════
    
    // Смещение 8-11: Минимальный радиус поля
    min_field_radius: f32,           // Минимальный радиус влияния
                                     // Диапазон: 0.0 - 100.0
                                     // По умолчанию: 0.1
    
    // Смещение 12-15: Максимальный радиус поля
    max_field_radius: f32,           // Максимальный радиус влияния
                                     // Диапазон: 0.0 - 1000.0
                                     // По умолчанию: 10.0
    
    // ═══════════════════════════════════════════════════════
    // ФЛАГИ ТОКЕНОВ (8 байт)
    // ═══════════════════════════════════════════════════════
    
    // Смещение 16-19: Общие флаги токенов
    token_flags: u32,                // Бит 0:  ALLOW_SPLITTING (токен может делиться)
                                     // Бит 1:  ALLOW_MERGING (токены могут объединяться)
                                     // Бит 2:  ALLOW_NEGATIVE_WEIGHT (для особых случаев)
                                     // Бит 3:  IMMUTABLE_POSITION (фиксирован в пространстве)
                                     // Бит 4:  INHERIT_PARENT_WEIGHT (из связей)
                                     // Бит 5:  AUTO_NORMALIZE_WEIGHT (автонормализация)
                                     // Бит 6:  ENABLE_FIELD_FORCES (включить силы поля)
                                     // Бит 7:  ENABLE_FIELD_DECAY (включить затухание поля)
                                     // Бит 8-31: Зарезервировано
    
    // Смещение 20-23: Флаги жизненного цикла
    lifecycle_flags: u32,            // Бит 0:  AUTO_GC (автоматическая сборка мусора)
                                     // Бит 1:  PRESERVE_ON_ZERO_WEIGHT (сохранять при нулевом весе)
                                     // Бит 2:  MARK_DEPRECATED (мягкое удаление)
                                     // Бит 3-31: Зарезервировано
    
    // ═══════════════════════════════════════════════════════
    // ЗНАЧЕНИЯ ПО УМОЛЧАНИЮ (8 байт)
    // ═══════════════════════════════════════════════════════
    
    // Смещение 24-27: Вес токена по умолчанию
    default_weight: f32,             // Начальный вес для новых токенов
                                     // По умолчанию: 1.0
    
    // Смещение 28-31: Радиус поля по умолчанию
    default_field_radius: f32,       // Начальный радиус поля
                                     // По умолчанию: 1.0
}

Итого: 32 байта
```

#### Объяснение флагов токенов

```
ALLOW_SPLITTING (разрешить деление):
    • Токен может делиться на несколько токенов
    • Применение: декомпозиция концепций
    • Творческий профиль: включено
    
ALLOW_MERGING (разрешить слияние):
    • Несколько токенов могут объединяться в один
    • Применение: слияние концепций
    • Творческий профиль: включено
    
ALLOW_NEGATIVE_WEIGHT (разрешить отрицательный вес):
    • Вес может быть отрицательным
    • Применение: ингибирующие отношения
    • Большинство профилей: отключено
    
IMMUTABLE_POSITION (неизменяемая позиция):
    • Токен не может двигаться в пространстве
    • Применение: точки привязки, фиксированные концепции
    
INHERIT_PARENT_WEIGHT (наследовать вес родителя):
    • Вес зависит от связанных токенов
    • По умолчанию: включено
    
AUTO_NORMALIZE_WEIGHT (автонормализация веса):
    • Вес автоматически масштабируется к диапазону [min, max]
    • Предотвращает экстремальные значения
    
ENABLE_FIELD_FORCES (включить силы поля):
    • Токен генерирует силовое поле
    • Влияет на близлежащие токены
    • По умолчанию: включено
    
ENABLE_FIELD_DECAY (включить затухание поля):
    • Сила поля затухает с расстоянием
    • По умолчанию: включено
```

---

### Блок 5: ОГРАНИЧЕНИЯ СВЯЗЕЙ (64 байта)

**Смещение: 288-351**

```rust
#[repr(C, packed)]
pub struct ConnectionConstraints {
    // ═══════════════════════════════════════════════════════
    // ПАРАМЕТРЫ ЖЁСТКОСТИ (12 байт)
    // ═══════════════════════════════════════════════════════
    
    // Смещение 0-3: Минимальная жёсткость
    min_rigidity: f32,               // Минимальная жёсткость связи
                                     // Диапазон: 0.0 - 1.0
                                     // По умолчанию: 0.1
                                     // 0.0 = полностью гибкая
                                     // 1.0 = полностью жёсткая
    
    // Смещение 4-7: Максимальная жёсткость
    max_rigidity: f32,               // Максимальная жёсткость связи
                                     // Диапазон: 0.0 - 1.0
                                     // По умолчанию: 0.9
    
    // Смещение 8-11: Жёсткость по умолчанию
    default_rigidity: f32,           // Начальная жёсткость для новых связей
                                     // По умолчанию: 0.5
    
    // ═══════════════════════════════════════════════════════
    // ПАРАМЕТРЫ СВЯЗНОСТИ (12 байт)
    // ═══════════════════════════════════════════════════════
    
    // Смещение 12-15: Минимальная сила связности
    min_coupling_strength: f32,      // Минимальная силовая связность
                                     // Диапазон: 0.0 - 10.0
                                     // По умолчанию: 0.01
    
    // Смещение 16-19: Максимальная сила связности
    max_coupling_strength: f32,      // Максимальная силовая связность
                                     // Диапазон: 0.0 - 100.0
                                     // По умолчанию: 10.0
    
    // Смещение 20-23: Связность по умолчанию
    default_coupling_strength: f32,  // Начальная связность для новых связей
                                     // По умолчанию: 1.0
    
    // ═══════════════════════════════════════════════════════
    // ПАРАМЕТРЫ ЗАТУХАНИЯ (12 байт)
    // ═══════════════════════════════════════════════════════
    
    // Смещение 24-27: Базовая скорость затухания
    base_decay_rate: f32,            // Базовая скорость ослабления связи
                                     // Диапазон: 0.0 - 1.0
                                     // По умолчанию: 0.01 (1% за единицу времени)
                                     // 0.0 = без затухания
    
    // Смещение 28-31: Фактор ускорения затухания
    decay_acceleration: f32,         // Как быстро ускоряется затухание
                                     // Диапазон: 0.0 - 10.0
                                     // По умолчанию: 1.5
                                     // Больше = быстрее экспоненциальное затухание
    
    // Смещение 32-35: Минимальный порог затухания
    min_decay_threshold: f32,        // Вес, ниже которого затухание останавливается
                                     // По умолчанию: 0.01
                                     // Предотвращает полное исчезновение
    
    // ═══════════════════════════════════════════════════════
    // УРОВНИ СИЛ (16 байт)
    // ═══════════════════════════════════════════════════════
    
    // Смещение 36-39: Множитель силы притяжения
    attraction_multiplier: f32,      // Масштабирует силы притяжения
                                     // Диапазон: 0.0 - 10.0
                                     // По умолчанию: 1.0
    
    // Смещение 40-43: Множитель силы отталкивания
    repulsion_multiplier: f32,       // Масштабирует силы отталкивания
                                     // Диапазон: 0.0 - 10.0
                                     // По умолчанию: 1.0
    
    // Смещение 44-47: Множитель силы натяжения
    tension_multiplier: f32,         // Масштабирует натяжение пружины
                                     // Диапазон: 0.0 - 10.0
                                     // По умолчанию: 1.0
    
    // Смещение 48-51: Коэффициент демпфирования
    damping_coefficient: f32,        // Рассеивание энергии
                                     // Диапазон: 0.0 - 1.0
                                     // По умолчанию: 0.1
                                     // Больше = быстрее успокоение
    
    // ═══════════════════════════════════════════════════════
    // ФЛАГИ СВЯЗЕЙ (4 байта)
    // ═══════════════════════════════════════════════════════
    
    // Смещение 52-55: Флаги поведения связей
    connection_flags: u32,           // Бит 0:  ENABLE_DECAY (включить затухание)
                                     // Бит 1:  ENABLE_REINFORCEMENT (использование укрепляет)
                                     // Бит 2:  BIDIRECTIONAL_FORCES (двунаправленные силы)
                                     // Бит 3:  NORMALIZE_FORCES (нормализовать силы)
                                     // Бит 4:  CLAMP_FORCES (ограничить экстремальные значения)
                                     // Бит 5-31: Зарезервировано
    
    // ═══════════════════════════════════════════════════════
    // ЗАРЕЗЕРВИРОВАНО (8 байт)
    // ═══════════════════════════════════════════════════════
    
    // Смещение 56-63: Зарезервировано для будущих ограничений
    reserved: [u32; 2],
}

Итого: 64 байта
```

#### Физическая модель

```
Связь как система пружина-демпфер:
    
    F_пружина = -k * (d - d0)
        k  = coupling_strength * rigidity (сила связности * жёсткость)
        d  = текущее расстояние
        d0 = длина покоя
    
    F_демпфирование = -c * v
        c = damping_coefficient (коэффициент демпфирования)
        v = относительная скорость
    
    F_общая = F_пружина + F_демпфирование
```

#### Модель затухания

```
Затухание веса со временем:
    
    Если вес > порог_затухания:
        вес -= базовая_скорость_затухания * dt
    
    Если вес < порог_затухания:
        вес -= базовая_скорость_затухания * ускорение_затухания * dt
    
    Если вес < мин_порог_затухания:
        затухание останавливается (сохранить минимальную связь)
```

---

### Блок 6: ЭВОЛЮЦИЯ И ПОДПИСКА (32 байта)

**Смещение: 352-383**

```rust
#[repr(C, packed)]
pub struct EvolutionSubscription {
    // ═══════════════════════════════════════════════════════
    // ОГРАНИЧЕНИЯ ЭВОЛЮЦИИ (16 байт)
    // ═══════════════════════════════════════════════════════
    
    // Смещение 0-3: Скорости мутации
    max_mutation_rate: f32,          // Максимальная скорость мутации (0.0 - 1.0)
                                     // По умолчанию: 0.1 (10%)
                                     // Исследователь: 0.2 (20%)
                                     // Аналитик: 0.05 (5%)
                                     // Творческий: 0.3 (30%)
    
    // Смещение 4-7: Параметры кроссовера
    max_crossover_rate: f32,         // Максимальная скорость кроссовера (0.0 - 1.0)
                                     // По умолчанию: 0.3 (30%)
                                     // Исследователь: 0.5 (50%)
                                     // Аналитик: 0.1 (10%)
    
    // Смещение 8-11: Параметры отбора
    selection_pressure: f32,         // Давление отбора (0.0 - 10.0)
                                     // По умолчанию: 2.0
                                     // Выше = сильнее отбор
    
    // Смещение 12-15: Элитизм
    elitism_count: u32,              // Количество элитных особей для сохранения
                                     // По умолчанию: 2
                                     // 0 = без элитизма
    
    // ═══════════════════════════════════════════════════════
    // ПОДПИСКА И КАРАНТИН (12 байт)
    // ═══════════════════════════════════════════════════════
    
    // Смещение 16-19: Настройки карантина
    quarantine_duration_s: u32,      // Длительность карантина в секундах
                                     // 60 = изменения низкого воздействия
                                     // 300 = среднего воздействия (по умолчанию)
                                     // 900 = высокого воздействия
                                     // 3600 = критические (смена профиля)
    
    // Смещение 20-22: Пороги валидации (упакованы, 3 байта)
    max_memory_growth_percent: u8,   // Максимальный рост памяти во время карантина
                                     // По умолчанию: 20 (20%)
                                     // Диапазон: 1-255
    
    max_connection_breaks: u8,       // Максимальное количество разрывов связей
                                     // По умолчанию: 10
                                     // Диапазон: 0-255
    
    max_token_churn_rate: u8,        // Максимальная скорость обновления токенов
                                     // По умолчанию: 30 (30%)
                                     // Диапазон: 0-100
    
    // Смещение 23: Флаги подписки
    subscription_flags: u8,          // Бит 0: BATCH_UPDATES (группировать изменения)
                                     // Бит 1: NOTIFY_ON_LOAD (отправлять при загрузке CDNA)
                                     // Бит 2: REQUIRE_ACK (модули должны подтвердить получение)
                                     // Бит 3: LOG_UPDATES (записывать в лог)
                                     // Бит 4-7: Зарезервировано
    
    // Смещение 24-27: Битовая маска затронутых модулей
    affected_modules: u32,           // Какие модули нуждаются в уведомлении
                                     // Бит 0:  TOKEN (токены)
                                     // Бит 1:  CONNECTION (связи)
                                     // Бит 2:  GRID (сетка)
                                     // Бит 3:  GRAPH (граф)
                                     // Бит 4:  FSC (FSC)
                                     // Бит 5:  GUARDIAN (страж)
                                     // Бит 6-31: Зарезервировано
    
    // ═══════════════════════════════════════════════════════
    // ФЛАГИ ЭВОЛЮЦИИ И ВЕРСИЯ (8 байт)
    // ═══════════════════════════════════════════════════════
    
    // Смещение 28-31: Флаги эволюции
    evolution_flags: u32,            // Бит 0:  ALLOW_CREATE_TOKEN (разрешить создание токенов)
                                     // Бит 1:  ALLOW_DELETE_TOKEN (разрешить удаление токенов)
                                     // Бит 2:  ALLOW_MODIFY_WEIGHT (разрешить изменение веса)
                                     // Бит 3:  ALLOW_CREATE_CONNECTION (разрешить создание связей)
                                     // Бит 4:  ALLOW_DELETE_CONNECTION (разрешить удаление связей)
                                     // Бит 5:  ALLOW_MODIFY_RIGIDITY (разрешить изменение жёсткости)
                                     // Бит 6:  ELITISM_ENABLED (элитизм включён)
                                     // Бит 7:  DIVERSITY_PRESERVATION (сохранение разнообразия)
                                     // Бит 8-31: Зарезервировано
    
    // Смещение 32-35: Указатель истории версий
    prev_version_hash: u32,          // CRC32 хеш предыдущей стабильной CDNA
                                     // 0 = нет предыдущей версии
                                     // Используется для отката
}

Итого: 32 байта
```

#### Рекомендации по длительности карантина

```
CHANGE_IMPACT_LOW (60 секунд):
    • Незначительные изменения параметров (±10%)
    • Корректировка одного масштаба измерения
    • Небольшие изменения лимитов связей
    
CHANGE_IMPACT_MEDIUM (300 секунд = 5 минут):
    • Значительные изменения параметров (±50%)
    • Изменения нескольких масштабов измерений
    • Модификации типов связей
    • Изменения диапазона весов токенов
    
CHANGE_IMPACT_HIGH (900 секунд = 15 минут):
    • Изменения физической модели
    • Модификации правил топологии
    • Изменения множителей сил
    • Изменения параметров затухания
    
CHANGE_IMPACT_CRITICAL (3600 секунд = 1 час):
    • Полная смена профиля
    • Одновременные изменения нескольких блоков
    • Экспериментальные конфигурации
```

#### Пороги валидации

```
max_memory_growth_percent (максимальный рост памяти в процентах):
    • Измеряется в течение периода карантина
    • Если память растёт > порог: ПРОВАЛ
    • По умолчанию: 20% (приемлемый рост)
    • Строгий: 10%, Разрешающий: 50%
    
max_connection_breaks (максимум разрывов связей):
    • Количество разорванных связей во время теста
    • Если разрывов > порог: ПРОВАЛ
    • По умолчанию: 10 разрывов
    • Аналитик: 5, Исследователь: 20
    
max_token_churn_rate (максимальная скорость обновления токенов):
    • (созданных + удалённых) / всего_токенов
    • Если обновление > порог: ПРЕДУПРЕЖДЕНИЕ или ПРОВАЛ
    • По умолчанию: 30%
    • Высокое обновление может указывать на нестабильность
```

---

## Система событий

### Типы событий

```rust
/// Детальные события изменения CDNA для системы подписки
#[derive(Debug, Clone)]
pub enum CDNAEvent {
    // ═══════════════════════════════════════════════════════
    // СОБЫТИЯ СЕТКИ
    // ═══════════════════════════════════════════════════════
    
    DimensionScaleChanged {
        dimension: u8,               // 0-7 (PHYSICAL до ABSTRACT)
        old_scale: f64,
        new_scale: f64,
    },
    
    DimensionFlagsChanged {
        dimension: u8,
        old_flags: u32,
        new_flags: u32,
    },
    
    // ═══════════════════════════════════════════════════════
    // СОБЫТИЯ ГРАФА
    // ═══════════════════════════════════════════════════════
    
    ConnectionTypesChanged {
        old_mask: u16,
        new_mask: u16,
        added_types: Vec<String>,
        removed_types: Vec<String>,
    },
    
    MaxNodeDegreeChanged {
        old_max: u32,
        new_max: u32,
    },
    
    MinConnectionWeightChanged {
        old_min: f32,
        new_min: f32,
    },
    
    TopologyFlagsChanged {
        old_flags: u32,
        new_flags: u32,
    },
    
    // ═══════════════════════════════════════════════════════
    // СОБЫТИЯ ТОКЕНОВ
    // ═══════════════════════════════════════════════════════
    
    WeightRangeChanged {
        old_min: f32,
        old_max: f32,
        new_min: f32,
        new_max: f32,
    },
    
    FieldRadiusChanged {
        old_min: f32,
        old_max: f32,
        new_min: f32,
        new_max: f32,
    },
    
    TokenFlagsChanged {
        old_flags: u32,
        new_flags: u32,
    },
    
    // ═══════════════════════════════════════════════════════
    // СОБЫТИЯ СВЯЗЕЙ
    // ═══════════════════════════════════════════════════════
    
    RigidityRangeChanged {
        old_min: f32,
        old_max: f32,
        new_min: f32,
        new_max: f32,
    },
    
    CouplingStrengthChanged {
        old_min: f32,
        old_max: f32,
        new_min: f32,
        new_max: f32,
    },
    
    DecayRateChanged {
        old_rate: f32,
        new_rate: f32,
    },
    
    // ═══════════════════════════════════════════════════════
    // СОБЫТИЯ ЭВОЛЮЦИИ
    // ═══════════════════════════════════════════════════════
    
    MutationRateChanged {
        old_rate: f32,
        new_rate: f32,
    },
    
    CrossoverRateChanged {
        old_rate: f32,
        new_rate: f32,
    },
    
    // ═══════════════════════════════════════════════════════
    // СОБЫТИЯ ПРОФИЛЯ
    // ═══════════════════════════════════════════════════════
    
    ProfileSwitched {
        old_id: u32,
        old_type: String,
        new_id: u32,
        new_type: String,
    },
    
    // ═══════════════════════════════════════════════════════
    // СИСТЕМНЫЕ СОБЫТИЯ
    // ═══════════════════════════════════════════════════════
    
    QuarantineStarted {
        duration_s: u32,
        change_impact: ChangeImpact,
    },
    
    QuarantineProgress {
        elapsed_s: u32,
        total_s: u32,
        health_metrics: HealthMetrics,
    },
    
    QuarantinePassed {
        duration_s: u32,
        final_metrics: HealthMetrics,
    },
    
    QuarantineFailed {
        reason: String,
        failed_metrics: HealthMetrics,
    },
    
    RollbackExecuted {
        from_version: u32,
        to_version: u32,
    },
}

/// Уровни воздействия изменений
#[derive(Debug, Clone, Copy)]
pub enum ChangeImpact {
    Low,        // 60s карантин
    Medium,     // 300s карантин
    High,       // 900s карантин
    Critical,   // 3600s карантин
}

/// Метрики здоровья во время карантина
#[derive(Debug, Clone)]
pub struct HealthMetrics {
    // Память
    memory_usage_mb: f32,
    memory_growth_percent: f32,
    
    // Связи
    connection_breaks: u32,
    connection_stability: f32,
    
    // Токены
    token_creation_rate: f32,
    token_deletion_rate: f32,
    token_churn: f32,
    
    // Граф
    graph_fragmentation: f32,
    avg_path_length: f32,
    clustering_coefficient: f32,
}
```

---

## Управление подписками

### API подписки

```rust
/// Менеджер подписок CDNA
pub struct CDNASubscriptionManager {
    subscribers: HashMap<ModuleID, Vec<EventFilter>>,
    event_queue: VecDeque<CDNAEvent>,
    batch_enabled: bool,
    batch_delay_ms: u32,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub enum ModuleID {
    Token,
    Connection,
    Grid,
    Graph,
    FSC,
    Guardian,
}

/// Фильтр событий для выборочной подписки
pub struct EventFilter {
    event_types: Vec<EventType>,
    priority: u8,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum EventType {
    GridChanges,
    GraphChanges,
    TokenChanges,
    ConnectionChanges,
    EvolutionChanges,
    ProfileChanges,
    SystemEvents,
}

impl CDNASubscriptionManager {
    pub fn new(batch_enabled: bool, batch_delay_ms: u32) -> Self {
        Self {
            subscribers: HashMap::new(),
            event_queue: VecDeque::new(),
            batch_enabled,
            batch_delay_ms,
        }
    }
    
    /// Подписать модуль на конкретные типы событий
    pub fn subscribe(&mut self, module: ModuleID, filter: EventFilter) {
        self.subscribers
            .entry(module)
            .or_insert_with(Vec::new)
            .push(filter);
    }
    
    /// Отписать модуль от всех событий
    pub fn unsubscribe(&mut self, module: ModuleID) {
        self.subscribers.remove(&module);
    }
    
    /// Опубликовать событие для всех подписанных модулей
    pub fn publish(&mut self, event: CDNAEvent) {
        if self.batch_enabled {
            self.event_queue.push_back(event);
        } else {
            self.dispatch_immediately(event);
        }
    }
    
    /// Выгрузить накопленные события
    pub fn flush_batch(&mut self) {
        while let Some(event) = self.event_queue.pop_front() {
            self.dispatch_immediately(event);
        }
    }
    
    fn dispatch_immediately(&self, event: CDNAEvent) {
        for (module, filters) in &self.subscribers {
            if self.should_notify(module, &filters, &event) {
                self.send_to_module(*module, event.clone());
            }
        }
    }
    
    fn should_notify(
        &self,
        _module: &ModuleID,
        filters: &[EventFilter],
        event: &CDNAEvent,
    ) -> bool {
        filters.iter().any(|f| f.matches(event))
    }
    
    fn send_to_module(&self, _module: ModuleID, _event: CDNAEvent) {
        // Реализация зависит от системы межмодульной коммуникации
        // Может использовать передачу сообщений, разделяемую память, каналы и т.д.
    }
}

impl EventFilter {
    pub fn matches(&self, event: &CDNAEvent) -> bool {
        let event_category = match event {
            CDNAEvent::DimensionScaleChanged { .. }
            | CDNAEvent::DimensionFlagsChanged { .. } => EventType::GridChanges,
            
            CDNAEvent::ConnectionTypesChanged { .. }
            | CDNAEvent::MaxNodeDegreeChanged { .. }
            | CDNAEvent::MinConnectionWeightChanged { .. }
            | CDNAEvent::TopologyFlagsChanged { .. } => EventType::GraphChanges,
            
            CDNAEvent::WeightRangeChanged { .. }
            | CDNAEvent::FieldRadiusChanged { .. }
            | CDNAEvent::TokenFlagsChanged { .. } => EventType::TokenChanges,
            
            CDNAEvent::RigidityRangeChanged { .. }
            | CDNAEvent::CouplingStrengthChanged { .. }
            | CDNAEvent::DecayRateChanged { .. } => EventType::ConnectionChanges,
            
            CDNAEvent::MutationRateChanged { .. }
            | CDNAEvent::CrossoverRateChanged { .. } => EventType::EvolutionChanges,
            
            CDNAEvent::ProfileSwitched { .. } => EventType::ProfileChanges,
            
            CDNAEvent::QuarantineStarted { .. }
            | CDNAEvent::QuarantineProgress { .. }
            | CDNAEvent::QuarantinePassed { .. }
            | CDNAEvent::QuarantineFailed { .. }
            | CDNAEvent::RollbackExecuted { .. } => EventType::SystemEvents,
        };
        
        self.event_types.contains(&event_category)
    }
}
```

### Пример использования

```rust
// Создать менеджер подписок
let mut sub_manager = CDNASubscriptionManager::new(
    true,  // группировка включена
    100,   // задержка группировки 100мс
);

// Подписать модуль Grid на изменения сетки
sub_manager.subscribe(
    ModuleID::Grid,
    EventFilter {
        event_types: vec![EventType::GridChanges],
        priority: 10,
    }
);

// Подписать модуль Token на изменения токенов и эволюции
sub_manager.subscribe(
    ModuleID::Token,
    EventFilter {
        event_types: vec![
            EventType::TokenChanges,
            EventType::EvolutionChanges,
        ],
        priority: 5,
    }
);

// Опубликовать событие
sub_manager.publish(CDNAEvent::DimensionScaleChanged {
    dimension: 7,
    old_scale: 10.0,
    new_scale: 15.0,
});

// Выгрузить пакет после задержки
std::thread::sleep(Duration::from_millis(100));
sub_manager.flush_batch();
```

---

## История версий

### Менеджер истории версий

```rust
/// Менеджер истории версий CDNA
pub struct CDNAHistory {
    // В памяти (горячее хранилище)
    current_stable: CDNA,
    previous_stable: Option<CDNA>,
    
    // Дисковое хранилище (холодное хранилище)
    history_dir: PathBuf,
    max_history_depth: u32,
    
    // Метаданные
    snapshots: Vec<CDNASnapshot>,
}

pub struct CDNASnapshot {
    cdna: CDNA,
    timestamp: u64,
    applied_by: String,
    change_reason: String,
    validation_passed: bool,
    version_hash: u32,
}

impl CDNAHistory {
    pub fn new(history_dir: PathBuf, max_depth: u32) -> Self {
        Self {
            current_stable: CDNA::default(),
            previous_stable: None,
            history_dir,
            max_history_depth: max_depth,
            snapshots: Vec::new(),
        }
    }
    
    /// Добавить новую версию (только если прошла валидацию)
    pub fn add_version(
        &mut self,
        cdna: CDNA,
        applied_by: String,
        reason: String,
    ) -> Result<(), CDNAError> {
        cdna.validate()?;
        
        let snapshot = CDNASnapshot {
            cdna: cdna.clone(),
            timestamp: current_timestamp(),
            applied_by,
            change_reason: reason,
            validation_passed: true,
            version_hash: cdna.compute_hash(),
        };
        
        self.previous_stable = Some(self.current_stable.clone());
        self.current_stable = cdna;
        self.snapshots.push(snapshot.clone());
        self.save_snapshot_to_disk(&snapshot)?;
        self.cleanup_old_versions()?;
        
        Ok(())
    }
    
    /// Откатиться к предыдущей стабильной версии
    pub fn rollback(&mut self) -> Result<CDNA, CDNAError> {
        match &self.previous_stable {
            Some(prev) => {
                let rolled_back = prev.clone();
                self.current_stable = rolled_back.clone();
                Ok(rolled_back)
            }
            None => Err(CDNAError::NoHistoryAvailable),
        }
    }
    
    /// Откатиться к конкретной версии по хешу
    pub fn rollback_to_version(&mut self, version_hash: u32) -> Result<CDNA, CDNAError> {
        if let Some(snapshot) = self.snapshots.iter()
            .find(|s| s.version_hash == version_hash) 
        {
            self.current_stable = snapshot.cdna.clone();
            return Ok(snapshot.cdna.clone());
        }
        
        self.load_version_from_disk(version_hash)
    }
    
    /// Получить историю версий (последние N версий)
    pub fn get_history(&self, count: usize) -> Vec<&CDNASnapshot> {
        self.snapshots.iter()
            .rev()
            .take(count)
            .collect()
    }
    
    fn save_snapshot_to_disk(&self, snapshot: &CDNASnapshot) -> Result<(), CDNAError> {
        let filename = format!(
            "cdna_v{:08x}_{}.bin",
            snapshot.version_hash,
            snapshot.timestamp
        );
        let path = self.history_dir.join(filename);
        
        snapshot.cdna.save(path.to_str().unwrap())?;
        
        let metadata_path = path.with_extension("meta");
        self.save_metadata(metadata_path, snapshot)?;
        
        Ok(())
    }
    
    fn load_version_from_disk(&self, version_hash: u32) -> Result<CDNA, CDNAError> {
        for entry in std::fs::read_dir(&self.history_dir)? {
            let entry = entry?;
            let filename = entry.file_name().to_string_lossy().to_string();
            
            if filename.starts_with(&format!("cdna_v{:08x}", version_hash)) {
                return CDNA::load(entry.path().to_str().unwrap());
            }
        }
        
        Err(CDNAError::VersionNotFound(version_hash))
    }
    
    fn cleanup_old_versions(&mut self) -> Result<(), CDNAError> {
        if self.snapshots.len() > self.max_history_depth as usize {
            let to_remove = self.snapshots.len() - self.max_history_depth as usize;
            
            for i in 0..to_remove {
                let snapshot = &self.snapshots[i];
                self.delete_snapshot_from_disk(snapshot.version_hash)?;
            }
            
            self.snapshots.drain(0..to_remove);
        }
        
        Ok(())
    }
    
    fn delete_snapshot_from_disk(&self, version_hash: u32) -> Result<(), CDNAError> {
        for entry in std::fs::read_dir(&self.history_dir)? {
            let entry = entry?;
            let filename = entry.file_name().to_string_lossy().to_string();
            
            if filename.starts_with(&format!("cdna_v{:08x}", version_hash)) {
                std::fs::remove_file(entry.path())?;
                
                let meta_path = entry.path().with_extension("meta");
                if meta_path.exists() {
                    std::fs::remove_file(meta_path)?;
                }
            }
        }
        
        Ok(())
    }
    
    fn save_metadata(&self, path: PathBuf, snapshot: &CDNASnapshot) -> Result<(), CDNAError> {
        use std::io::Write;
        
        let metadata = format!(
            "timestamp: {}\napplied_by: {}\nreason: {}\nvalidation: {}\n",
            snapshot.timestamp,
            snapshot.applied_by,
            snapshot.change_reason,
            snapshot.validation_passed
        );
        
        let mut file = std::fs::File::create(path)?;
        file.write_all(metadata.as_bytes())?;
        
        Ok(())
    }
}
```

### Вычисление хеша

```rust
impl CDNA {
    /// Вычислить CRC32 хеш (исключая заголовок)
    pub fn compute_hash(&self) -> u32 {
        let bytes = unsafe {
            let ptr = (self as *const Self as *const u8).add(64);
            std::slice::from_raw_parts(ptr, 320)
        };
        
        crc32(bytes)
    }
}

fn crc32(data: &[u8]) -> u32 {
    let mut crc = 0xFFFFFFFF_u32;
    
    for &byte in data {
        crc ^= byte as u32;
        for _ in 0..8 {
            if crc & 1 != 0 {
                crc = (crc >> 1) ^ 0xEDB88320;
            } else {
                crc >>= 1;
            }
        }
    }
    
    !crc
}
```

---

## Правила валидации

### Полная валидация

```rust
impl CDNA {
    /// Всесторонняя валидация
    pub fn validate(&self) -> Result<(), CDNAError> {
        self.validate_header()?;
        self.validate_grid()?;
        self.validate_graph()?;
        self.validate_token()?;
        self.validate_connection()?;
        self.validate_evolution_subscription()?;
        self.validate_consistency()?;
        
        Ok(())
    }
    
    fn validate_header(&self) -> Result<(), CDNAError> {
        if &self.header.magic != b"NGCDNA21" {
            return Err(CDNAError::InvalidMagic);
        }
        
        if self.header.version_major < self.header.min_compatible_major
            || self.header.version_major > self.header.max_compatible_major
        {
            return Err(CDNAError::IncompatibleVersion {
                expected: self.header.min_compatible_major as u16,
                found: self.header.version_major,
            });
        }
        
        if self.header.total_size != 384 {
            return Err(CDNAError::InvalidSize {
                expected: 384,
                found: self.header.total_size,
            });
        }
        
        if !self.verify_checksum() {
            return Err(CDNAError::ChecksumMismatch);
        }
        
        match self.header.profile_state {
            0x00 | 0x01 | 0x02 | 0x03 | 0xFF => Ok(()),
            _ => Err(CDNAError::InvalidFlags {
                field: "profile_state",
                value: self.header.profile_state,
            }),
        }
    }
    
    fn validate_grid(&self) -> Result<(), CDNAError> {
        for i in 0..8 {
            let scale = self.grid.dimension_scale[i];
            if scale < 0.0 || scale > 100.0 {
                return Err(CDNAError::InvalidRange {
                    field: "dimension_scale",
                    min: 0.0,
                    max: 100.0,
                });
            }
        }
        
        Ok(())
    }
    
    fn validate_graph(&self) -> Result<(), CDNAError> {
        if self.graph.max_node_degree == 0 {
            return Err(CDNAError::InvalidRange {
                field: "max_node_degree",
                min: 1.0,
                max: 10000.0,
            });
        }
        
        if self.graph.min_connection_weight < 0.0
            || self.graph.min_connection_weight > 1.0
        {
            return Err(CDNAError::InvalidRange {
                field: "min_connection_weight",
                min: 0.0,
                max: 1.0,
            });
        }
        
        Ok(())
    }
    
    fn validate_token(&self) -> Result<(), CDNAError> {
        if self.token.min_weight > self.token.max_weight {
            return Err(CDNAError::InvalidRange {
                field: "token weight",
                min: self.token.min_weight,
                max: self.token.max_weight,
            });
        }
        
        if self.token.min_field_radius > self.token.max_field_radius {
            return Err(CDNAError::InvalidRange {
                field: "field_radius",
                min: self.token.min_field_radius,
                max: self.token.max_field_radius,
            });
        }
        
        Ok(())
    }
    
    fn validate_connection(&self) -> Result<(), CDNAError> {
        if self.connection.min_rigidity > self.connection.max_rigidity {
            return Err(CDNAError::InvalidRange {
                field: "rigidity",
                min: self.connection.min_rigidity,
                max: self.connection.max_rigidity,
            });
        }
        
        if self.connection.min_coupling_strength > self.connection.max_coupling_strength {
            return Err(CDNAError::InvalidRange {
                field: "coupling_strength",
                min: self.connection.min_coupling_strength,
                max: self.connection.max_coupling_strength,
            });
        }
        
        if self.connection.base_decay_rate < 0.0
            || self.connection.base_decay_rate > 1.0
        {
            return Err(CDNAError::InvalidRange {
                field: "base_decay_rate",
                min: 0.0,
                max: 1.0,
            });
        }
        
        Ok(())
    }
    
    fn validate_evolution_subscription(&self) -> Result<(), CDNAError> {
        if self.evolution.max_mutation_rate < 0.0
            || self.evolution.max_mutation_rate > 1.0
        {
            return Err(CDNAError::InvalidRange {
                field: "max_mutation_rate",
                min: 0.0,
                max: 1.0,
            });
        }
        
        if self.evolution.max_crossover_rate < 0.0
            || self.evolution.max_crossover_rate > 1.0
        {
            return Err(CDNAError::InvalidRange {
                field: "max_crossover_rate",
                min: 0.0,
                max: 1.0,
            });
        }
        
        if self.evolution.max_memory_growth_percent == 0 {
            return Err(CDNAError::InvalidRange {
                field: "max_memory_growth_percent",
                min: 1.0,
                max: 255.0,
            });
        }
        
        Ok(())
    }
    
    fn validate_consistency(&self) -> Result<(), CDNAError> {
        // Проверка: вес токена по умолчанию в диапазоне
        if self.token.default_weight < self.token.min_weight
            || self.token.default_weight > self.token.max_weight
        {
            return Err(CDNAError::InconsistentFlags {
                reason: "default_weight вне диапазона [min_weight, max_weight]",
            });
        }
        
        // Проверка: жёсткость связи по умолчанию в диапазоне
        if self.connection.default_rigidity < self.connection.min_rigidity
            || self.connection.default_rigidity > self.connection.max_rigidity
        {
            return Err(CDNAError::InconsistentFlags {
                reason: "default_rigidity вне диапазона [min_rigidity, max_rigidity]",
            });
        }
        
        Ok(())
    }
    
    fn verify_checksum(&self) -> bool {
        let computed = self.compute_checksum();
        
        // Сравнить первые 16 байт
        &computed[..16] == &self.header.data_checksum[..]
    }
    
    fn compute_checksum(&self) -> [u8; 16] {
        use sha2::{Sha256, Digest};
        
        let bytes = unsafe {
            let ptr = (self as *const Self as *const u8).add(64);
            std::slice::from_raw_parts(ptr, 320)
        };
        
        let hash = Sha256::digest(bytes);
        let mut result = [0u8; 16];
        result.copy_from_slice(&hash[..16]);
        result
    }
}
```

---

## Система профилей

### Определения профилей

```rust
impl CDNA {
    /// Создать профиль по умолчанию
    pub fn default() -> Self {
        let mut cdna = Self::new();
        cdna.header.profile_type = ProfileType::Custom as u32;
        cdna.header.profile_id = 0x00000001;
        cdna.update_checksum();
        cdna
    }
    
    /// Создать из типа профиля
    pub fn from_profile(profile_type: ProfileType) -> Self {
        match profile_type {
            ProfileType::Explorer => Self::explorer_profile(),
            ProfileType::Analyzer => Self::analyzer_profile(),
            ProfileType::Creative => Self::creative_profile(),
            ProfileType::Custom => Self::default(),
        }
    }
    
    /// Профиль Исследователь: свободные ограничения, высокая эволюция
    fn explorer_profile() -> Self {
        let mut cdna = Self::new();
        
        cdna.header.profile_type = ProfileType::Explorer as u32;
        cdna.header.profile_id = 0x00000100;
        
        // Сетка: сбалансированные масштабы
        cdna.grid.dimension_scale = [1.0, 1.5, 1.2, 2.0, 3.0, 2.5, 2.0, 5.0];
        
        // Граф: разрешающий
        cdna.graph.allowed_connection_types = 0xFFFF; // все типы
        cdna.graph.max_node_degree = 500;
        cdna.graph.min_connection_weight = 0.01;
        cdna.graph.topology_flags = 
            TopologyFlags::ALLOW_SELF_LOOPS
            | TopologyFlags::ALLOW_MULTI_EDGES
            | TopologyFlags::ALLOW_DYNAMIC_TOPOLOGY;
        
        // Эволюция: высокие скорости
        cdna.evolution.max_mutation_rate = 0.2;
        cdna.evolution.max_crossover_rate = 0.5;
        cdna.evolution.quarantine_duration_s = 300;
        
        cdna.update_checksum();
        cdna
    }
    
    /// Профиль Аналитик: строгие ограничения, низкая эволюция
    fn analyzer_profile() -> Self {
        let mut cdna = Self::new();
        
        cdna.header.profile_type = ProfileType::Analyzer as u32;
        cdna.header.profile_id = 0x00000200;
        
        // Сетка: фокус на абстрактном
        cdna.grid.dimension_scale = [1.0, 1.0, 1.0, 1.5, 10.0, 5.0, 3.0, 20.0];
        
        // Граф: ограничивающий
        cdna.graph.allowed_connection_types = 0x0888; // CAUSALITY | DEPENDENCY | INHERITANCE
        cdna.graph.max_node_degree = 100;
        cdna.graph.min_connection_weight = 0.3;
        cdna.graph.topology_flags = 
            TopologyFlags::DIRECTED
            | TopologyFlags::WEIGHTED
            | TopologyFlags::REQUIRE_CONNECTED;
        
        // Связи: жёсткие
        cdna.connection.min_rigidity = 0.7;
        cdna.connection.max_rigidity = 1.0;
        
        // Эволюция: консервативная
        cdna.evolution.max_mutation_rate = 0.05;
        cdna.evolution.max_crossover_rate = 0.1;
        cdna.evolution.quarantine_duration_s = 900;
        
        cdna.update_checksum();
        cdna
    }
    
    /// Профиль Творческий: экспериментальный, высокая вариативность
    fn creative_profile() -> Self {
        let mut cdna = Self::new();
        
        cdna.header.profile_type = ProfileType::Creative as u32;
        cdna.header.profile_id = 0x00000300;
        
        // Сетка: экзотические масштабы (Фибоначчи)
        cdna.grid.dimension_scale = [1.0, 2.0, 3.0, 5.0, 8.0, 13.0, 21.0, 34.0];
        
        // Граф: только пользовательские типы
        cdna.graph.allowed_connection_types = 0xC000; // CUSTOM_1 | CUSTOM_2
        cdna.graph.topology_flags = TopologyFlags::ALLOW_ALL;
        
        // Токены: экзотические функции
        cdna.token.token_flags = 
            TokenFlags::ALLOW_SPLITTING
            | TokenFlags::ALLOW_MERGING
            | TokenFlags::ALLOW_NEGATIVE_WEIGHT;
        
        // Эволюция: очень высокая
        cdna.evolution.max_mutation_rate = 0.3;
        cdna.evolution.quarantine_duration_s = 3600;
        
        cdna.update_checksum();
        cdna
    }
}

#[derive(Debug, Clone, Copy)]
pub enum ProfileType {
    Explorer = 0x01,
    Analyzer = 0x02,
    Creative = 0x03,
    Custom = 0xFF,
}
```

---

## Примеры использования

### Пример 1: Создать и сохранить CDNA по умолчанию

```rust
// Создать CDNA по умолчанию
let mut cdna = CDNA::default();

// Настроить при необходимости
cdna.grid.dimension_scale[7] = 15.0; // Увеличить важность абстрактного

// Сохранить в файл
cdna.save("config/cdna_default.bin")?;

println!("CDNA сохранена: {} байт", std::mem::size_of::<CDNA>());
```

### Пример 2: Загрузить и валидировать

```rust
// Загрузить из файла
let cdna = CDNA::load("config/cdna_default.bin")?;

// Валидировать
match cdna.validate() {
    Ok(_) => println!("CDNA валидна ✓"),
    Err(e) => eprintln!("Валидация провалилась: {:?}", e),
}

// Проверить состояние профиля
match cdna.header.profile_state {
    0x00 => println!("Профиль: СТАБИЛЬНЫЙ"),
    0x01 => println!("Профиль: КАРАНТИН"),
    _ => println!("Профиль: ДРУГОЕ"),
}
```

### Пример 3: Создание на основе профиля

```rust
// Создать профиль исследователя
let explorer = CDNA::from_profile(ProfileType::Explorer);
explorer.save("profiles/explorer.bin")?;

// Создать профиль аналитика
let analyzer = CDNA::from_profile(ProfileType::Analyzer);
analyzer.save("profiles/analyzer.bin")?;

// Создать творческий профиль
let creative = CDNA::from_profile(ProfileType::Creative);
creative.save("profiles/creative.bin")?;
```

### Пример 4: Рабочий процесс карантина

```rust
// Загрузить текущую стабильную CDNA
let mut history = CDNAHistory::new(
    PathBuf::from("cdna_history"),
    10  // хранить 10 версий
);

// Пользователь предлагает изменение
let mut proposed = history.current_stable.clone();
proposed.grid.dimension_scale[7] = 20.0;
proposed.header.profile_state = 0x02; // ПРЕДЛОЖЕНА

// Начать карантин
proposed.header.profile_state = 0x01; // КАРАНТИН
proposed.evolution.quarantine_duration_s = 300; // 5 минут

// Отслеживать метрики здоровья (псевдокод)
let start = Instant::now();
while start.elapsed().as_secs() < 300 {
    let metrics = monitor_system_health();
    
    if metrics.memory_growth_percent > 20.0 {
        eprintln!("Карантин ПРОВАЛЕН: рост памяти слишком высокий");
        proposed.header.profile_state = 0xFF; // ПРОВАЛЕН
        history.rollback()?;
        break;
    }
    
    std::thread::sleep(Duration::from_secs(10));
}

// Если прошёл, перевести в стабильную
if proposed.header.profile_state == 0x01 {
    proposed.header.profile_state = 0x00; // СТАБИЛЬНАЯ
    history.add_version(proposed, "user".to_string(), "Увеличен масштаб абстрактного".to_string())?;
}
```

### Пример 5: Подписка на события

```rust
// Настроить подписку
let mut sub_manager = CDNASubscriptionManager::new(true, 100);

// Grid подписывается на изменения измерений
sub_manager.subscribe(
    ModuleID::Grid,
    EventFilter {
        event_types: vec![EventType::GridChanges],
        priority: 10,
    }
);

// Применить изменение CDNA
let old_scale = cdna.grid.dimension_scale[7];
cdna.grid.dimension_scale[7] = 15.0;

// Опубликовать событие
sub_manager.publish(CDNAEvent::DimensionScaleChanged {
    dimension: 7,
    old_scale,
    new_scale: 15.0,
});

// Выгрузить после задержки пакета
std::thread::sleep(Duration::from_millis(100));
sub_manager.flush_batch();
```

---

## Константы

```rust
// Версия
pub const VERSION_MAJOR: u16 = 2;
pub const VERSION_MINOR: u16 = 1;
pub const VERSION_PATCH: u8 = 0;

// Размер
pub const CDNA_SIZE: usize = 384;

// Длительности карантина
pub const QUARANTINE_DURATION_LOW: u32 = 60;
pub const QUARANTINE_DURATION_MEDIUM: u32 = 300;
pub const QUARANTINE_DURATION_HIGH: u32 = 900;
pub const QUARANTINE_DURATION_CRITICAL: u32 = 3600;

// Пороги валидации
pub const DEFAULT_MAX_MEMORY_GROWTH: u8 = 20;
pub const DEFAULT_MAX_CONNECTION_BREAKS: u8 = 10;
pub const DEFAULT_MAX_TOKEN_CHURN: u8 = 30;

// История
pub const DEFAULT_HISTORY_DEPTH: u32 = 10;

// Подписка
pub const DEFAULT_BATCH_DELAY_MS: u32 = 100;
```

---

## Типы ошибок

```rust
#[derive(Debug)]
pub enum CDNAError {
    InvalidMagic,
    IncompatibleVersion { expected: u16, found: u16 },
    InvalidSize { expected: u32, found: u32 },
    ChecksumMismatch,
    InvalidRange { field: &'static str, min: f32, max: f32 },
    InvalidFlags { field: &'static str, value: u32 },
    InconsistentFlags { reason: &'static str },
    NoHistoryAvailable,
    VersionNotFound(u32),
    IOError(String),
}

impl From<std::io::Error> for CDNAError {
    fn from(e: std::io::Error) -> Self {
        CDNAError::IOError(e.to_string())
    }
}
```

---

## Резюме

**CDNA v2.1 — Полная спецификация**

✅ **Размер:** 384 байта (6 кеш-линий)  
✅ **Блоки:** 6 (Заголовок, Сетка, Граф, Токены, Связи, Эволюция+Подписка)  
✅ **События:** 15+ детальных типов событий  
✅ **Подписка:** Модель Pub/Sub с фильтрацией  
✅ **Версионирование:** История с возможностью отката  
✅ **Профили:** Исследователь, Аналитик, Творческий, Пользовательский  
✅ **Карантин:** 4-уровневая система валидации  
✅ **Валидация:** Всесторонние правила для всех параметров

**Изменения от v2.0:**
- Блок 6 переименован в "Эволюция и подписка"
- Добавлена система подписки (модель pub/sub)
- Добавлены пороги валидации карантина
- Добавлено поле profile_state в заголовке
- Контрольная сумма сокращена до 16 байт (достаточно)
- Magic number изменён на "NGCDNA21"

**Готова к реализации на Rust!** 🎯

---

**Конец спецификации CDNA v2.1**
