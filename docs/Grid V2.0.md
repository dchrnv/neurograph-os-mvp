# Grid V2

# Grid Specification v2.0 — Official Documentation

**Статус:** Official Specification  
**Версия:** 2.0.0  
**Дата:** 2025-10-21  
**Зависимости:** Token v2.0, Connection v1.0  
**Целевые языки:** Rust, C++, любой системный язык

---

## Оглавление

1. [Обзор и философия](#1-обзор-и-философия)
2. [Система координат](#2-система-координат)
3. [Архитектура Grid](#3-архитектура-grid)
4. [Семантические поля](#4-семантические-поля)
5. [Пространственная индексация](#5-пространственная-индексация)
6. [Операции Grid](#6-операции-grid)
7. [Алгоритмы поиска](#7-алгоритмы-поиска)
8. [Производительность](#8-производительность)
9. [Интеграция с модулями](#9-интеграция-с-модулями)
10. [Инварианты и валидация](#10-инварианты-и-валидация)
11. [Сериализация состояния](#11-сериализация-состояния)

---

## 1. Обзор и философия

### 1.1 Определение

**Grid (Сетка)** — это фундаментальная координатная система NeuroGraph OS, определяющая 8-мерное семантическое пространство, в котором существуют и взаимодействуют все информационные единицы системы.

Grid является **первичной структурой**: она не возникает из Token, а предоставляет координатное пространство, в котором Token фиксируют свои позиции.

### 1.2 Природа Grid

Grid — это **не физический контейнер**. Это концептуальная система координат, аналогичная:

- Декартовой системе координат в геометрии
- Пространству-времени в физике
- Семантическому пространству в лингвистике

**Grid определяет:**

- 8 независимых координатных пространств (L1-L8)
- Метрику расстояния в каждом пространстве
- Правила взаимодействия между узлами через поля

**Grid НЕ определяет:**

- Структуру узлов (это Token v2.0)
- Структуру связей (это Connection v1.0)
- Алгоритмы обхода графа (это Graph module)

### 1.3 Философия дизайна

**Первичность координат:** Grid существует независимо от узлов. Пустая Grid — это валидное состояние системы, представляющее 8-мерное пространство без населяющих его сущностей.

**Многомерность:** Grid — это не единое пространство, а система из 8 ортогональных пространств, каждое со своей семантикой. Узел существует одновременно во всех 8 пространствах.

**Sparse природа:** Grid не является плотной матрицей. Координатное пространство огромно (int16 даёт ±32,767 по каждой оси), но заполнено узлами разреженно.

**Эмерджентность полей:** Семантические поля возникают естественно из взаимодействия узлов через их `field_radius` и `field_strength`, без централизованного управления.

**Гибридная природа:** Grid совмещает:

- Пространственную модель — позиционирование и поиск соседей
- Графовую модель — связи между узлами (через Connection)

### 1.4 Роль в NeuroGraph OS

Grid выполняет следующие функции:

1. **Координатная система** — определяет "где" существует информация
2. **Индексная структура** — обеспечивает быстрый пространственный поиск
3. **Семантическое пространство** — позиция в Grid несёт смысловую нагрузку
4. **Основа для полей** — механизм формирования областей смысла
5. **Общая карта** — единая система отсчёта для всех модулей

### 1.5 Отличия от других модулей

| Аспект | Grid | Token | Connection | Graph |
|--------|------|-------|------------|-------|
| Определяет | Координатные пространства | Структуру узла | Структуру связи | Алгоритмы обхода |
| Размерность | 8 пространств × 3 оси | Фиксирует позицию в Grid | Связывает узлы | Навигирует по связям |
| Природа | Система координат | Дискретная единица | Отношение | Топология |
| Операции | FindNeighbors, RangeQuery | Хранение данных | Силовое взаимодействие | Traverse, PathFind |

---

## 2. Система координат

### 2.1 Определение 8 пространств

Grid определяет 8 независимых ортогональных пространств, каждое из которых представляет отдельный аспект семантического существования информации.

**Фундаментальное свойство:** Пространства независимы. Позиция узла в L1 не влияет на его позицию в L2. Узел может быть близко к другому узлу в одном пространстве и далеко в другом.

**Идентификация пространств:**

- **Level 0:** L1 - Physical (Физическое пространство)
- **Level 1:** L2 - Sensory (Сенсорное пространство)
- **Level 2:** L3 - Motor (Моторное пространство)
- **Level 3:** L4 - Emotional (Эмоциональное пространство)
- **Level 4:** L5 - Cognitive (Когнитивное пространство)
- **Level 5:** L6 - Social (Социальное пространство)
- **Level 6:** L7 - Temporal (Темпоральное пространство)
- **Level 7:** L8 - Abstract (Абстрактное пространство)

### 2.2 L1: Physical (Физическое пространство)

**Назначение:** Представление физической локации и пространственных отношений.

**Оси:**

- **X:** Позиция Восток/Запад (м)
- **Y:** Позиция Север/Юг (м)
- **Z:** Высота (м)

**Характеристики:**

- Диапазон: ±327.67 метра (масштаб 100, int16)
- Метрика: Евклидово расстояние
- Единицы: метры
- Применение: Локальное позиционирование (комната, здание, квартал)

**Семантика близости:** Узлы, близкие в L1, находятся рядом в физическом пространстве. Расстояние соответствует реальному физическому расстоянию.

**Особенности:**

- Подчиняется законам физической геометрии
- Может использоваться для пространственных ограничений
- Связь с реальным миром для embodied агентов

### 2.3 L2: Sensory (Сенсорное пространство)

**Назначение:** Параметры сенсорного восприятия и внимания.

**Оси:**

- **X:** Салиентность (заметность): 0.0 (незаметно) → 1.0 (очень заметно)
- **Y:** Валентность (привлекательность): -1.0 (отталкивающе) → +1.0 (привлекательно)
- **Z:** Новизна (степень изменения): 0.0 (привычно) → 1.0 (абсолютно ново)

**Характеристики:**

- Диапазон: ±1.0 (нормализовано, масштаб 10000)
- Метрика: Евклидово расстояние в нормализованном пространстве
- Единицы: безразмерные, нормализованные
- Применение: Управление вниманием, фильтрация стимулов

**Семантика близости:** Узлы, близкие в L2, воспринимаются системой похожим образом с точки зрения внимания и аффективной оценки.

**Особенности:**

- Субъективное пространство (зависит от состояния системы)
- Динамически изменяется (новое становится привычным)
- Критично для систем с ограниченными ресурсами внимания

### 2.4 L3: Motor (Моторное пространство)

**Назначение:** Параметры движения и действия.

**Оси:**

- **X:** Линейная скорость (м/с)
- **Y:** Линейное ускорение (м/с²)
- **Z:** Угловая скорость (рад/с)

**Характеристики:**

- Диапазон: ±32.767 в соответствующих единицах (масштаб 1000)
- Метрика: Евклидово расстояние
- Единицы: м/с, м/с², рад/с
- Применение: Планирование движения, управление актуаторами

**Семантика близости:** Узлы, близкие в L3, представляют похожие паттерны движения или действия.

**Особенности:**

- Связано с физическим пространством (L1)
- Может использовать темпоральное пространство (L7) для траекторий
- Критично для embodied и robotic систем

### 2.5 L4: Emotional (Эмоциональное пространство)

**Назначение:** Аффективное состояние согласно VAD модели.

**Оси:**

- **X:** Valence (валентность): -1.0 (неудовольствие) → +1.0 (удовольствие)
- **Y:** Arousal (возбуждение): -1.0 (пассивность) → +1.0 (активность)
- **Z:** Dominance (доминирование): -1.0 (подчинение) → +1.0 (контроль)

**Характеристики:**

- Диапазон: ±1.0 (нормализовано, масштаб 10000)
- Метрика: Евклидово расстояние в VAD пространстве
- Единицы: безразмерные, нормализованные
- Применение: Аффективные вычисления, эмоциональный интеллект

**Семантика близости:** Узлы, близкие в L4, вызывают или представляют похожие эмоциональные состояния.

**Примеры позиций:**

- Радость: V=+0.8, A=+0.5, D=+0.3
- Грусть: V=-0.6, A=-0.4, D=-0.5
- Гнев: V=-0.5, A=+0.8, D=+0.7
- Спокойствие: V=+0.3, A=-0.6, D=0.0

**Особенности:**

- Субъективное пространство
- Может влиять на другие пространства (например, L5 - когнитивное)
- Основа для empathic и social AI

### 2.6 L5: Cognitive (Когнитивное пространство)

**Назначение:** Параметры когнитивной обработки.

**Оси:**

- **X:** Когнитивная нагрузка: 0.0 (нет нагрузки) → 1.0 (максимальная)
- **Y:** Уровень абстракции: 0.0 (конкретный) → 1.0 (философский)
- **Z:** Уверенность: 0.0 (неуверенность) → 1.0 (абсолютная уверенность)

**Характеристики:**

- Диапазон: 0.0 → 1.0 (нормализовано, масштаб 10000)
- Метрика: Евклидово расстояние
- Единицы: безразмерные, нормализованные
- Применение: Управление вниманием, планирование, рассуждения

**Семантика близости:** Узлы, близкие в L5, требуют похожего уровня когнитивных ресурсов и обработки.

**Особенности:**

- Связано с L2 (внимание) и L8 (абстракция)
- Критично для meta-cognitive процессов
- Может использоваться для load balancing в системе

### 2.7 L6: Social (Социальное пространство)

**Назначение:** Параметры социального взаимодействия.

**Оси:**

- **X:** Социальная дистанция: -1.0 (враждебный) → +1.0 (интимный)
- **Y:** Иерархический статус: -1.0 (подчинённый) → +1.0 (доминантный)
- **Z:** Принадлежность: -1.0 (чужой/out-group) → +1.0 (свой/in-group)

**Характеристики:**

- Диапазон: ±1.0 (нормализовано, масштаб 10000)
- Метрика: Евклидово расстояние
- Единицы: безразмерные, нормализованные
- Применение: Социальная навигация, моделирование отношений

**Семантика близости:** Узлы, близкие в L6, представляют похожие социальные отношения или роли.

**Примеры позиций:**

- Друг: дистанция=+0.8, статус=0.0, принадлежность=+0.9
- Начальник: дистанция=-0.3, статус=+0.7, принадлежность=+0.5
- Враг: дистанция=-0.9, статус=-0.5, принадлежность=-0.8

**Особенности:**

- Реляционное пространство (определяется относительно других)
- Может быть множественным (разные отношения с разными агентами)
- Критично для multi-agent систем

### 2.8 L7: Temporal (Темпоральное пространство)

**Назначение:** Временная локализация и ритмы.

**Оси:**

- **X:** Временное смещение (секунды, относительно timestamp)
- **Y:** Длительность (секунды)
- **Z:** Периодичность/Частота (Герцы)

**Характеристики:**

- Диапазон X, Y: ±327 секунд (масштаб 100)
- Диапазон Z: 0-32.7 Гц (масштаб 1000)
- Метрика: Специфичная для темпоральных запросов
- Единицы: секунды, Герцы
- Применение: Временная координация, планирование, ритмы

**Семантика близости:** Узлы, близкие в L7, происходят близко во времени или имеют похожие темпоральные характеристики.

**Особенности:**

- Связано с timestamp в Token
- Может представлять относительное время
- Критично для последовательных процессов и ритмов

### 2.9 L8: Abstract (Абстрактное пространство)

**Назначение:** Семантические отношения и логика.

**Оси:**

- **X:** Семантическая близость: -1.0 (антоним) → +1.0 (синоним)
- **Y:** Каузальная связь: -1.0 (ингибирует) → +1.0 (вызывает)
- **Z:** Логическая модальность: -1.0 (невозможно) → +1.0 (необходимо)

**Характеристики:**

- Диапазон: ±1.0 (нормализовано, масштаб 10000)
- Метрика: Евклидово расстояние
- Единицы: безразмерные, нормализованные
- Применение: Семантический анализ, рассуждения, логический вывод

**Семантика близости:** Узлы, близкие в L8, семантически связаны — имеют похожее значение, причинность или логическую необходимость.

**Особенности:**

- Наиболее абстрактное пространство
- Может быть связано с другими через metaphor mapping
- Критично для символьных рассуждений

### 2.10 Масштабы и единицы

**Сводная таблица:**

| Пространство | Масштаб X | Масштаб Y | Масштаб Z | Диапазон X | Диапазон Y | Диапазон Z |
|--------------|-----------|-----------|-----------|------------|------------|------------|
| L1 Physical | 100 | 100 | 100 | ±327.67 м | ±327.67 м | ±327.67 м |
| L2 Sensory | 10000 | 10000 | 10000 | 0.0-1.0 | ±1.0 | 0.0-1.0 |
| L3 Motor | 1000 | 1000 | 1000 | ±32.767 м/с | ±32.767 м/с² | ±32.767 рад/с |
| L4 Emotional | 10000 | 10000 | 10000 | ±1.0 | ±1.0 | ±1.0 |
| L5 Cognitive | 10000 | 10000 | 10000 | 0.0-1.0 | 0.0-1.0 | 0.0-1.0 |
| L6 Social | 10000 | 10000 | 10000 | ±1.0 | ±1.0 | ±1.0 |
| L7 Temporal | 100 | 100 | 1000 | ±327 сек | 0-327 сек | 0-32.7 Гц |
| L8 Abstract | 10000 | 10000 | 10000 | ±1.0 | ±1.0 | ±1.0 |

**Преобразование координат:**

Координаты хранятся как int16 в Token, но интерпретируются Grid с учётом масштаба:

**Кодирование (float → int16):**

```
encoded = clamp(round(value × scale), -32767, 32767)
```

**Декодирование (int16 → float):**

```
decoded = encoded / scale
```

**Специальное значение:**

```
127 (int16) = координата не определена (None)
```

### 2.11 Метрики расстояния

**Евклидово расстояние (по умолчанию):**

Для пространства L на уровне level:

```
d = sqrt((x₁ - x₂)² + (y₁ - y₂)² + (z₁ - z₂)²)
```

где x, y, z — декодированные координаты

**Манхэттенское расстояние (опционально):**

```
d = |x₁ - x₂| + |y₁ - y₂| + |z₁ - z₂|
```

**Максимальное расстояние / Чебышёва (опционально):**

```
d = max(|x₁ - x₂|, |y₁ - y₂|, |z₁ - z₂|)
```

**Выбор метрики:** Метрика может быть специфична для пространства. 

**Рекомендации:**

- L1, L3: Евклидово (физические расстояния)
- L2, L4, L5, L6, L8: Евклидово (нормализованные пространства)
- L7: Специальная темпоральная метрика

### 2.12 Boundary conditions

**Границы пространства:**

- Минимум: -32767 (int16)
- Максимум: +32767 (int16)

**Поведение на границах:**

1. **Clipping (по умолчанию):** Координаты ограничиваются диапазоном
2. **Wrapping (опционально):** Координаты зацикливаются (для торовых топологий)
3. **Rejection:** Узлы за границами не принимаются

**Неопределённые координаты:**

- Значение 127 (int16) означает "координата отсутствует"
- Узел может иметь определённые координаты только в некоторых пространствах
- Например, абстрактный концепт может иметь координаты в L8, но не в L1

---

## 3. Архитектура Grid

### 3.1 Компоненты системы

Grid состоит из следующих логических компонентов:

**1. Координатная система (Coordinate System):**

- 8 пространств L1-L8
- Метрики расстояния
- Правила трансформации координат

**2. Хранилище узлов (Node Storage):**

- Hash map: token_id → Token
- Быстрый доступ O(1) по ID
- Поддержка sparse представления

**3. Пространственные индексы (Spatial Indexes):**

- 8 индексов (по одному на пространство)
- k-d деревья, octrees или grid-based
- Обеспечивают быстрый поиск соседей

**4. Графовые структуры (Graph Structures):**

- Adjacency lists для связей
- Использует Connection v1.0 для хранения
- Обеспечивает графовые запросы

**5. Менеджер полей (Field Manager):**

- Отслеживает зоны влияния
- Вычисляет плотность
- Идентифицирует семантические поля

### 3.2 Узлы в Grid

Grid не хранит структуру узлов, но работает с ними через интерфейс:

**Требования к узлу:**

Узел должен предоставлять:

- `id: uint32` (уникальный идентификатор)
- `coordinates: [8][3] int16` (позиции в 8 пространствах)
- `field_radius: float` (0.0-2.55)
- `field_strength: float` (0.0-1.0)
- `weight: float` (0.0-1.0)
- `flags:` включая `FLAG_ACTIVE`

**Grid видит узел как:**

- Точку в 8-мерном пространстве
- Источник поля с радиусом и силой
- Носителя веса (важности)
- Субъект для индексации

### 3.3 Sparse представление

**Концепция разреженности:**

**Теоретический размер Grid:**

- Каждое пространство: 65535 × 65535 × 65535 возможных позиций
- 8 пространств
- = Астрономически большое пространство состояний

**Реальное заполнение:**

- Количество узлов: 10³ - 10⁶ (типично)
- Процент заполнения: < 10⁻¹⁵ %

**Следствия:**

- Нельзя использовать плотные массивы
- Необходимы sparse структуры данных
- Индексы критичны для производительности

**Стратегии хранения:**

1. Hash map для узлов (token_id → Token)
2. Spatial indexes для пространственных запросов
3. Adjacency lists для связей

### 3.4 Состояние Grid

Grid в любой момент времени характеризуется:

**Статическое состояние:**

- Множество узлов N = {n₁, n₂, ..., nₖ}
- Позиции узлов в 8 пространствах
- Множество связей между узлами

**Динамическое состояние:**

- Распределение плотности в пространствах
- Активные семантические поля
- Паттерны активации

**Инварианты:**

1. Каждый узел имеет уникальный ID
2. Координаты узла в диапазоне [-32767, 32767] или 127 (None)
3. Узел может присутствовать в нескольких или во всех пространствах
4. Связи ссылаются только на существующие узлы

### 3.5 Lifecycle узлов в Grid

**Добавление узла:**

1. Валидация узла (уникальность ID, корректность координат)
2. Добавление в node storage (hash map)
3. Индексация в spatial indexes (для определённых пространств)
4. Обновление field manager (если field_radius > 0)
5. Опционально: создание связей с соседями

**Обновление координат узла:**

1. Получение старых координат
2. Удаление из spatial indexes (для изменённых пространств)
3. Обновление координат в node storage
4. Реиндексация в spatial indexes
5. Обновление field manager

**Удаление узла:**

1. Удаление из spatial indexes
2. Удаление всех связей, ссылающихся на узел
3. Удаление из field manager
4. Удаление из node storage

### 3.6 Boundary management

**Проверка границ:**

При добавлении/обновлении узла проверяется:

```
for level in 0..7:
    for axis in (x, y, z):
        assert coord ≠ 127 OR -32767 ≤ coord ≤ 32767
```

**Стратегии выхода за границы:**

**1. Clipping (рекомендуется):**

```
coord_clamped = clamp(coord, -32767, 32767)
```

**2. Rejection:**

```
if coord < -32767 OR coord > 32767:
    reject_node()
```

**3. Wrapping (для специальных случаев):**

```
coord_wrapped = ((coord + 32767) % 65535) - 32767
```

### 3.7 Multi-space presence

Узел может иметь координаты в любом подмножестве 8 пространств:

**Примеры:**

**Физический объект:**

```
L1: (10.5, 20.0, 1.5)  → позиция в комнате
L3: (0.0, 0.0, 0.0)    → неподвижен
L8: None               → нет абстрактного значения
Остальные: None
```

**Абстрактный концепт:**

```
L1-L7: None            → нет физических/темпоральных координат
L8: (0.8, 0.3, 0.5)    → семантическая позиция
```

**Событие:**

```
L1: (50.0, 30.0, 0.0)  → где произошло
L7: (0.0, 60.0, 0.0)   → временные характеристики (длительность 60 сек)
L8: (0.2, 0.9, 0.7)    → семантика (каузальная связь высокая)
Остальные: None или определены
```

**Проверка присутствия:**

Узел присутствует в пространстве level, если:

```
node.coordinates[level][0] ≠ 127
```

---

## 4. Семантические поля

### 4.1 Определение поля

**Семантическое поле** — это область в одном из 8 пространств Grid, характеризующаяся высокой плотностью узлов и/или сильным взаимодействием через `field_radius` и `field_strength`.

**Поле НЕ является:**

- Физической сущностью с границами
- Предопределённой структурой
- Статичным объектом

**Поле ЯВЛЯЕТСЯ:**

- Эмерджентным паттерном
- Динамической областью влияния
- Результатом взаимодействия узлов

### 4.2 Механизм формирования полей

Каждый узел создаёт "зону влияния":

Узел n с позицией P в пространстве L имеет:

- Центр: P = (x, y, z)
- Радиус влияния: r = n.field_radius
- Сила влияния: s = n.field_strength

**Поле в точке Q:**

Любая точка Q в пространстве L испытывает влияние от n:

```
distance = ||P - Q||
if distance ≤ r:
    influence = s × (1 - distance/r)  // линейное затухание
else:
    influence = 0
```

**Суммарное влияние всех узлов:**

```
field_strength(Q) = Σ influence_i(Q) для всех узлов i
```

где influence_i(Q) — влияние узла i на точку Q

### 4.3 field_radius и field_strength

Эти поля определены в Token v2.0, но их семантика реализуется Grid.

**field_radius (радиус влияния):**

- Тип: float
- Диапазон: 0.0 - 2.55
- Кодирование в Token: uint8 (масштаб 100)

**Интерпретация Grid:**

- Определяет размер зоны влияния узла в пространстве
- Измеряется в единицах соответствующего пространства
- field_radius = 0 → узел не создаёт поля (точечный узел)
- field_radius > 0 → узел влияет на окружающее пространство

**field_strength (сила поля):**

- Тип: float
- Диапазон: 0.0 - 1.0
- Кодирование в Token: uint8 (масштаб 255)

**Интерпретация Grid:**

- Определяет интенсивность влияния на максимальном расстоянии
- field_strength = 0 → узел не влияет на соседей
- field_strength = 1.0 → максимальное влияние
- Влияние затухает с расстоянием

**Взаимодействие параметров:**

**Узел с большим радиусом и малой силой:**

```
field_radius = 2.0
field_strength = 0.2
→ Широкое, но слабое влияние
```

**Узел с малым радиусом и большой силой:**

```
field_radius = 0.3
field_strength = 0.9
→ Узкое, но сильное влияние
```

**Оптимальная конфигурация (синоним, важный концепт):**

```
field_radius = 1.0
field_strength = 0.8
→ Умеренное, сильное влияние
```

### 4.4 Функции затухания влияния

**Линейное затухание (по умолчанию):**

```
influence(distance) = field_strength × (1 - distance / field_radius)
```

Свойства:

- Простое вычисление
- Плавное убывание
- influence(0) = field_strength
- influence(field_radius) = 0

**Квадратичное затухание:**

```
influence(distance) = field_strength × (1 - (distance / field_radius)²)
```

Свойства:

- Более крутое падение на краях
- Более плоское в центре

**Гауссово затухание:**

```
influence(distance) = field_strength × exp(-(distance² / (2σ²)))
где σ = field_radius / 3
```

Свойства:

- Гладкое затухание
- Никогда не достигает нуля
- Более реалистично для некоторых процессов

**Выбор функции:**

- Определяется конфигурацией Grid
- Может быть специфичен для пространства
- Рекомендуется линейное для простоты

### 4.5 Плотность и идентификация полей

**Плотность в точке:**

Плотность узлов в окрестности радиуса R вокруг точки Q:

```
density(Q, R) = count(nodes within distance R from Q) / volume(R)
где volume(R) = (4/3)πR³ для 3D пространства
```

**Плотность поля (field density):**

Взвешенная плотность с учётом field_strength:

```
field_density(Q, R) = Σ (node.weight × influence(Q, node)) / volume(R)
```

**Идентификация полей:**

Поле существует в области, где:

1. field_density(Q) > DENSITY_THRESHOLD
2. Область связна (соседние точки также имеют высокую плотность)
3. Размер области > MIN_FIELD_SIZE

**Алгоритм обнаружения полей:**

1. Сэмплирование пространства (grid-based или random)
2. Вычисление field_density в точках сэмпла
3. Кластеризация точек с высокой плотностью
4. Определение границ полей
5. Вычисление характеристик полей (центр, радиус, сила)

**Характеристики поля:**

```rust
Field {
    center: (x, y, z)     // Центр масс узлов в поле
    radius: float         // Средний радиус от центра до узлов
    strength: float       // Средняя сила влияния
    node_count: uint      // Количество узлов в поле
    total_weight: float   // Суммарный вес узлов
    level: uint8          // Пространство (0-7)
}
```

### 4.6 Динамика полей

Поля являются динамическими структурами:

**Формирование поля:**

1. Появление узлов в области пространства
2. Установка field_radius и field_strength
3. Перекрытие зон влияния
4. Превышение DENSITY_THRESHOLD
5. Кристаллизация поля

**Эволюция поля:**

Поле изменяется при:

- Добавлении новых узлов в область
- Удалении узлов из области
- Изменении координат узлов (миграция)
- Изменении field_radius/strength узлов
- Изменении weight узлов

**Слияние полей:**

Два близких поля могут слиться, если:

```
distance(field1.center, field2.center) < (field1.radius + field2.radius)
```

Результат:

```
merged_field.center = weighted_average(field1.center, field2.center)
merged_field.radius = max(field1.radius, field2.radius)
merged_field.node_count = field1.node_count + field2.node_count
```

**Распад поля:**

Поле распадается, если:

```
field_density < DECAY_THRESHOLD
OR node_count < MIN_NODES_IN_FIELD
```

### 4.7 Взаимодействие полей и Connection

Connection влияет на формирование полей:

Связи (Connection) создают "притяжение" между узлами:

- Узлы со связями SYNONYM стремятся быть ближе
- Узлы со связями ANTONYM стремятся быть дальше
- Сила притяжения/отталкивания определяется:
  - connection.rigidity
  - connection.pull_strength
  - connection.preferred_distance

**Результат:**

```
Узлы самоорганизуются в пространстве под действием сил от Connection
↓
Формируются кластеры узлов
↓
Кластеры создают области высокой плотности
↓
Области высокой плотности = семантические поля
```

Grid НЕ вычисляет силы (это делает Connection), но:

- Предоставляет метрики расстояния
- Обновляет индексы при изменении позиций
- Идентифицирует результирующие поля

### 4.8 Типы полей по пространствам

**L1 (Physical) поля:**

- Представляют физические локации
- Примеры: "кухня", "офис", "парк"
- Узлы: объекты, находящиеся в этих местах

**L2 (Sensory) поля:**

- Представляют паттерны восприятия
- Примеры: "яркие стимулы", "незаметные фоновые"
- Узлы: сенсорные данные с похожими характеристиками

**L4 (Emotional) поля:**

- Представляют эмоциональные состояния
- Примеры: "радостные события", "тревожные ситуации"
- Узлы: события/концепты с похожей аффективной окраской

**L8 (Abstract) поля:**

- Представляют семантические области
- Примеры: "животные", "транспорт", "абстрактные концепты"
- Узлы: концепты с похожим значением

### 4.9 Практическое применение полей

**Поиск по контексту:**

Найти узлы в том же семантическом поле, что и заданный узел:

1. Определить, в каких полях находится узел
2. Получить все узлы этих полей
3. Ранжировать по релевантности

**Обобщение:**

Создать новый узел, представляющий поле:

1. Идентифицировать поле
2. Вычислить центр поля
3. Создать узел с координатами = центр поля
4. Создать связи HYPERNYM от узлов поля к новому узлу

**Визуализация:**

Отобразить структуру знаний:

1. Идентифицировать все поля в L8 (Abstract)
2. Визуализировать поля как области
3. Отобразить узлы внутри полей
4. Показать связи между полями

---

## 5. Пространственная индексация

### 5.1 Необходимость индексов

**Проблема наивного поиска:**

Найти соседей узла в пространстве L:

```
Naive approach: проверить расстояние до ВСЕХ узлов
Сложность: O(N) где N = количество узлов

Для N = 1,000,000:
1 запрос = 1,000,000 вычислений расстояния
Неприемлемо
```

**Решение: пространственные индексы**

```
Предобработка: построить индекс O(N log N)
Запрос: O(log N + k) где k = количество соседей
```

### 5.2 Требования к индексам

**Функциональные требования:**

1. Поддержка вставки узла: `insert(node)`
2. Поддержка удаления узла: `remove(node_id)`
3. Поддержка обновления: `update(node)`
4. Поиск k ближайших соседей: `knn(point, k)`
5. Поиск в радиусе: `range_query(point, radius)`
6. Поиск в прямоугольнике: `rect_query(min_corner, max_corner)`

**Нефункциональные требования:**

1. Эффективность для sparse данных
2. Низкое потребление памяти
3. Быстрая перестройка при обновлениях
4. Поддержка параллельных запросов (thread-safe)
5. Устойчивость к вырожденным случаям (все узлы в одной точке)

### 5.3 Структуры данных для индексации

#### k-d Tree (k-dimensional tree)

**Описание:**

- Бинарное дерево разбиения пространства
- Каждый уровень делит по другой оси (X, Y, Z циклично)
- Листья содержат узлы

**Характеристики:**

- Построение: O(N log N)
- Поиск NN: O(log N) в среднем, O(N) в худшем
- Вставка: O(log N)
- Удаление: O(log N) + возможна перебалансировка
- Память: O(N)

**Преимущества:**

- Простота реализации
- Хорошая производительность для статичных данных
- Эффективен для малой размерности (3D)

**Недостатки:**

- Деградация при частых обновлениях
- Требует периодической перебалансировки
- Не оптимален для очень sparse данных

#### Octree

**Описание:**

- Дерево разбиения 3D пространства на октанты
- Каждый узел имеет до 8 детей (октанты)
- Рекурсивное деление до достижения критерия остановки

**Характеристики:**

- Построение: O(N log N)
- Поиск NN: O(log N)
- Вставка: O(log N)
- Удаление: O(log N)
- Память: O(N) до O(8N) в худшем случае

**Преимущества:**

- Естественное разбиение 3D пространства
- Хорошо для визуализации
- Эффективен для неравномерного распределения

**Недостатки:**

- Больше памяти чем k-d tree
- Сложнее реализация
- Может быть неоптимален для очень вытянутых кластеров

#### Grid-based (Uniform Grid)

**Описание:**

- Пространство разбивается на регулярную сетку ячеек
- Каждая ячейка содержит список узлов
- Hash map: cell_coordinates → list[node_id]

**Характеристики:**

- Построение: O(N)
- Поиск NN: O(1) для доступа к ячейке + O(k) для проверки соседей
- Вставка: O(1)
- Удаление: O(1)
- Память: O(N + C) где C = количество непустых ячеек

**Преимущества:**

- Очень быстрая вставка/удаление
- Простая реализация
- Идеален для динамических данных
- Хорошо для равномерного распределения

**Недостатки:**

- Требует выбора размера ячейки
- Неэффективен для крайне неравномерного распределения
- Может требовать много памяти для больших пространств

#### R-tree (и варианты R*-tree, R+-tree)

**Описание:**

- Дерево для индексации прямоугольных областей
- Узлы представляют MBR (Minimum Bounding Rectangle)
- Используется в базах данных

**Характеристики:**

- Построение: O(N log N)
- Поиск NN: O(log N)
- Вставка: O(log N)
- Удаление: O(log N)
- Память: O(N)

**Преимущества:**

- Оптимизирован для range queries
- Хорошо для пространственных БД
- Эффективная упаковка данных

**Недостатки:**

- Сложная реализация
- Overhead для точечных запросов
- Может требовать rebalancing

### 5.4 Рекомендуемая архитектура индексов

**Гибридный подход:**

Для каждого из 8 пространств:

```
if данные равномерно распределены:
    использовать Grid-based index
else if данные сильно кластеризованы:
    использовать Octree
else:
    использовать k-d Tree (по умолчанию)
```

**Конкретные рекомендации:**

- L1 (Physical): Grid-based (объекты обычно равномерны в пространстве)
- L2 (Sensory): k-d Tree (распределение варьируется)
- L3 (Motor): Grid-based (скорости обычно в ограниченном диапазоне)
- L4 (Emotional): k-d Tree (эмоции кластеризуются)
- L5 (Cognitive): k-d Tree
- L6 (Social): k-d Tree (социальные отношения кластеризуются)
- L7 (Temporal): Специализированный индекс (timeline)
- L8 (Abstract): k-d Tree (семантика сильно кластеризована)

### 5.5 Параметры индексов

**k-d Tree:**

```
MAX_LEAF_SIZE = 10-50          // Максимум узлов в листе перед разделением
REBALANCE_THRESHOLD = 0.3      // Перебалансировать если unbalanced > 30%
MAX_DEPTH = 12                 // Максимальная глубина дерева
```

**Octree:**

```
MAX_NODES_PER_LEAF = 20        // Максимум узлов в листе
MIN_CELL_SIZE = 0.01           // Минимальный размер ячейки
```

**Grid-based:**

```
CELL_SIZE = median(field_radius) × 2  // Размер ячейки ~ удвоенный медианный радиус
INITIAL_BUCKETS = 1000                // Начальный размер hash map
LOAD_FACTOR = 0.75                    // Порог для расширения hash map
```

### 5.6 Операции с индексами

**Вставка узла:**

Алгоритм:

```
1. Для каждого пространства level в 0..7:
    if node.coordinates[level][0] ≠ 127:  // Координата определена
        extract coordinates(node, level) → (x, y, z)
        index[level].insert(node.id, (x, y, z))
2. Обновить статистику индекса
3. Проверить необходимость rebalancing
```

**Удаление узла:**

Алгоритм:

```
1. Для каждого индекса, содержащего узел:
    index[level].remove(node.id)
2. Обновить статистику
```

**Обновление координат:**

Алгоритм:

```
1. Для каждого изменённого пространства level:
    if old_coords[level] существовали:
        index[level].remove(node.id)
    if new_coords[level] существуют:
        index[level].insert(node.id, new_coords[level])
2. Оптимизация: если new ≈ old (в пределах epsilon):
    skip update (избежать overhead)
```

### 5.7 Обслуживание индексов

**Перебалансировка:**

Периодически (или по триггеру):

```
for each index:
    if index.is_unbalanced():
        index.rebuild()
```

Критерии unbalanced (для k-d Tree):

```
depth_variance > THRESHOLD
OR leaf_size_variance > THRESHOLD
```

**Статистика индексов:**

```rust
Index Statistics {
    node_count: uint              // Количество индексированных узлов
    depth_avg: float              // Средняя глубина
    depth_max: uint               // Максимальная глубина
    leaf_size_avg: float          // Средний размер листа
    queries_per_second: uint      // Throughput
    avg_query_time_ms: float      // Средняя latency
    last_rebuild_time: timestamp
}
```

**Мониторинг:**

Отслеживать:

- Деградацию производительности (avg_query_time увеличивается)
- Несбалансированность (depth_max >> depth_avg)
- Утечки памяти (node_count не соответствует реальному)

### 5.8 Параллельный доступ к индексам

**Read-Write Lock стратегия:**

Для каждого индекса:

- Множественные одновременные read операции (knn, range_query)
- Эксклюзивный write при модификации (insert, remove, update)

**Lock-free для Grid-based:**

Grid-based индекс может использовать:

- Concurrent hash map (DashMap в Rust)
- Atomic операции для счётчиков
- Минимальная блокировка

**Batch updates:**

Для минимизации блокировок:

1. Собрать множество изменений в буфер
2. Заблокировать индекс
3. Применить все изменения за один раз
4. Разблокировать

---

## 6. Операции Grid

### 6.1 Базовые операции

#### InsertNode(node: Token)

**Назначение:** Добавить узел в Grid

**Предусловия:**

- node.id уникален (не существует в Grid)
- node.coordinates валидны

**Алгоритм:**

1. Валидация узла
2. Добавление в node_storage[node.id] = node
3. Для каждого пространства с определёнными координатами:
   spatial_index[level].insert(node.id, coords)
4. Если node.field_radius > 0:
   field_manager.register(node)

**Постусловия:**

- Узел присутствует в Grid
- Индексы обновлены

**Сложность:** O(log N) для каждого индексированного пространства

#### GetNode(node_id: uint32) → Token

**Назначение:** Получить узел по ID

**Алгоритм:**

```
return node_storage.get(node_id)
```

**Сложность:** O(1)

#### RemoveNode(node_id: uint32)

**Назначение:** Удалить узел из Grid

**Алгоритм:**

1. node = GetNode(node_id)
2. Для каждого индекса:
   spatial_index[level].remove(node_id)
3. field_manager.unregister(node)
4. Удалить все связи, ссылающиеся на node_id (через Connection)
5. node_storage.remove(node_id)

**Сложность:** O(log N × L + E)  
где L = количество индексированных пространств  
E = количество связей узла

#### UpdateNodeCoordinates(node_id: uint32, new_coords: [8][3]int16)

**Назначение:** Обновить координаты узла

**Алгоритм:**

1. node = GetNode(node_id)
2. old_coords = node.coordinates
3. Для каждого пространства level:
   ```
   if old_coords[level] ≠ new_coords[level]:
       if old_coords[level] определены:
           spatial_index[level].remove(node_id)
       if new_coords[level] определены:
           spatial_index[level].insert(node_id, new_coords[level])
   ```
4. node.coordinates = new_coords
5. field_manager.update(node)

**Сложность:** O(log N × C)  
где C = количество изменённых пространств

### 6.2 Пространственные запросы

#### FindNeighbors(node_id: uint32, level: uint8, radius: Option<float>) → List[uint32]

**Назначение:** Найти соседей узла в заданном пространстве

**Параметры:**

- node_id: ID целевого узла
- level: Пространство (0-7)
- radius: Радиус поиска (или None для использования node.field_radius)

**Алгоритм:**

1. node = GetNode(node_id)
2. if node.coordinates[level][0] ≠ 127:
   return []  // Узел не в этом пространстве
3. center = decode_coordinates(node.coordinates[level])
4. search_radius = radius.unwrap_or(node.field_radius)
5. neighbors = spatial_index[level].range_query(center, search_radius)
6. neighbors.remove(node_id)  // Исключить сам узел
7. return neighbors

**Возвращает:** Список ID узлов в радиусе

**Сложность:** O(log N + k) где k = количество соседей

#### KNearestNeighbors(point: (float, float, float), level: uint8, k: uint) → List[(uint32, float)]

**Назначение:** Найти k ближайших узлов к заданной точке

**Параметры:**

- point: Координаты точки в пространстве level
- level: Пространство (0-7)
- k: Количество соседей

**Алгоритм:**

1. neighbors = spatial_index[level].knn_query(point, k)
2. return [(node_id, distance), ...] отсортированный по distance

**Возвращает:** Список пар (ID узла, расстояние)

**Сложность:** O(log N + k)

#### RangeQuery(min_corner: (float, float, float), max_corner: (float, float, float), level: uint8) → List[uint32]

**Назначение:** Найти все узлы в прямоугольной области

**Параметры:**

- min_corner: Минимальные координаты (x, y, z)
- max_corner: Максимальные координаты (x, y, z)
- level: Пространство (0-7)

**Алгоритм:**

```
1. return spatial_index[level].rect_query(min_corner, max_corner)
```

**Возвращает:** Список ID узлов в области

**Сложность:** O(log N + k)

### 6.3 Измерение расстояний

#### Distance(node_id_a: uint32, node_id_b: uint32, level: uint8) → Option<float>

**Назначение:** Вычислить расстояние между двумя узлами в пространстве

**Алгоритм:**

1. node_a = GetNode(node_id_a)
2. node_b = GetNode(node_id_b)
3. if node_a.coordinates[level][0] ≠ 127 OR node_b.coordinates[level][0] ≠ 127:
   return None  // Один из узлов не в этом пространстве
4. coords_a = decode_coordinates(node_a.coordinates[level])
5. coords_b = decode_coordinates(node_b.coordinates[level])
6. return euclidean_distance(coords_a, coords_b)

**Возвращает:** Расстояние или None

**Сложность:** O(1)

#### MultiSpaceDistance(node_id_a: uint32, node_id_b: uint32, weights: [8]float) → float

**Назначение:** Вычислить взвешенное расстояние по всем пространствам

**Параметры:**

- weights: Веса для каждого пространства (сумма = 1.0)

**Алгоритм:**

1. total_distance = 0.0
2. Для каждого level в 0..7:
   ```
   if weights[level] > 0:
       dist = Distance(node_id_a, node_id_b, level)
       if dist is not None:
           // Нормализация по максимальному расстоянию в пространстве
           normalized_dist = dist / max_distance[level]
           total_distance += weights[level] × normalized_dist
   ```
3. return total_distance

**Возвращает:** Комбинированное расстояние [0, 1]

**Сложность:** O(8) = O(1)

### 6.4 Запросы по полям

#### GetNodesInField(field: Field) → List[uint32]

**Назначение:** Получить все узлы в семантическом поле

**Алгоритм:**

1. return RangeQuery(
   min_corner = field.center - field.radius,
   max_corner = field.center + field.radius,
   level = field.level
   )
2. Опционально: фильтровать по field_density

**Сложность:** O(log N + k)

#### IdentifyFields(level: uint8, density_threshold: float) → List[Field]

**Назначение:** Идентифицировать все семантические поля в пространстве

**Алгоритм:**

1. Получить все узлы в пространстве level
2. Вычислить field_density для сэмплированных точек
3. Кластеризовать точки с плотностью > density_threshold
4. Для каждого кластера:
   compute field characteristics (center, radius, strength)
5. return List[Field]

**Сложность:** O(N × S) где S = количество сэмплов

**Примечание:** Тяжёлая операция, выполняется периодически или по запросу

### 6.5 Batch операции

#### BatchInsertNodes(nodes: List[Token])

**Назначение:** Эффективная вставка множества узлов

**Алгоритм:**

1. Сортировать nodes по координатам (для оптимизации индексов)
2. Заблокировать все индексы для записи
3. Для каждого node:
   InsertNode(node) without individual locking
4. Разблокировать индексы
5. Опционально: rebuild индексов если требуется

**Преимущества:** Минимизация lock contention

**Сложность:** O(N log N + M log M) где M = количество новых узлов

#### BatchUpdateCoordinates(updates: List[(uint32, [8][3]int16)])

**Назначение:** Обновить координаты множества узлов

**Алгоритм:**

1. Группировать updates по пространствам
2. Для каждого пространства level:
   batch_update_index(level, updates_for_level)

**Сложность:** O(M log N) где M = количество обновлений

### 6.6 Статистические операции

#### GetGridStatistics() → GridStats

**Возвращает глобальную статистику:**

```rust
{
    total_nodes: uint,
    nodes_per_space: [8]uint,
    avg_field_radius: float,
    avg_field_strength: float,
    total_fields: uint,
    memory_usage_bytes: uint64,
    index_statistics: [8]IndexStats
}
```

**Сложность:** O(1) если статистика кэшируется

#### GetSpaceStatistics(level: uint8) → SpaceStats

**Возвращает статистику для конкретного пространства:**

```rust
{
    node_count: uint,
    bounding_box: (min_corner, max_corner),
    density_map: Map[(x,y,z) → float],
    field_count: uint,
    avg_node_distance: float
}
```

**Сложность:** O(N) для пространства

---

## 7. Алгоритмы поиска

### 7.1 Алгоритм FindNeighbors (детализация)

**Полная спецификация:**

```rust
FindNeighbors(
    node_id: uint32,
    level: uint8,
    radius: Option<float>,
    max_results: Option<uint>,
    filters: Option<NodeFilter>
) → List[(uint32, float)]
```

**Параметры:**

- node_id: ID центрального узла
- level: Пространство поиска (0-7)
- radius: Радиус поиска (None = использовать node.field_radius)
- max_results: Максимальное количество результатов (None = без ограничений)
- filters: Опциональные фильтры (по типу, весу, флагам)

**Возвращает:** Список пар (neighbor_id, distance), отсортированный по расстоянию

**Алгоритм (детальный):**

**Шаг 1: Валидация и подготовка**

```
node = GetNode(node_id)
if node is None:
    return Error("Node not found")

if node.coordinates[level][0] ≠ 127:
    return []  // Узел не в этом пространстве

center = decode_coordinates(node.coordinates[level])
search_radius = radius.unwrap_or(node.field_radius)

if search_radius ≤ 0:
    return []  // Нулевой радиус
```

**Шаг 2: Пространственный запрос**

```
candidate_ids = spatial_index[level].range_query(center, search_radius)

// Исключить сам узел
candidate_ids.remove(node_id)
```

**Шаг 3: Вычисление расстояний**

```
results = []
for candidate_id in candidate_ids:
    candidate = GetNode(candidate_id)
    
    // Применить фильтры
    if filters is not None:
        if not filters.matches(candidate):
            continue
    
    // Вычислить точное расстояние
    coords = decode_coordinates(candidate.coordinates[level])
    dist = euclidean_distance(center, coords)
    
    // Проверить, что действительно в радиусе (может быть false positive от индекса)
    if dist ≤ search_radius:
        results.append((candidate_id, dist))
```

**Шаг 4: Сортировка и ограничение**

```
results.sort_by(|a, b| a.1.cmp(&b.1))  // Сортировка по расстоянию

if max_results is not None:
    results.truncate(max_results)

return results
```

**Сложность:** O(log N + k log k) где k = количество кандидатов

### 7.2 Алгоритм влияния узлов

#### ComputeInfluence(target_point: (float, float, float), level: uint8, radius: float) → float

**Назначение:** Вычислить суммарное влияние всех узлов на заданную точку

**Параметры:**

- target_point: Координаты точки в пространстве
- level: Пространство (0-7)
- radius: Радиус поиска влияющих узлов

**Алгоритм:**

1. Найти все узлы в радиусе от точки:

```
nearby_nodes = spatial_index[level].range_query(target_point, radius)
```

2. Для каждого узла вычислить влияние:

```
total_influence = 0.0
for node_id in nearby_nodes:
    node = GetNode(node_id)
    coords = decode_coordinates(node.coordinates[level])
    distance = euclidean_distance(target_point, coords)
    
    // Проверить, попадает ли точка в зону влияния узла
    if distance ≤ node.field_radius:
        // Применить функцию затухания
        influence = node.field_strength × (1 - distance / node.field_radius)
        
        // Взвесить на вес узла
        weighted_influence = influence × node.weight
        total_influence += weighted_influence

2. return total_influence
```

**Возвращает:** Суммарное влияние [0, ∞)

**Сложность:** O(log N + k)

### 7.3 Алгоритм кластеризации

#### ClusterNodes(level: uint8, method: ClusteringMethod) → List[Cluster]

**Назначение:** Группировка узлов в кластеры в заданном пространстве

**Методы кластеризации:**

- DENSITY_BASED (DBSCAN-подобный)
- HIERARCHICAL (иерархическая кластеризация)
- K_MEANS (k-средних)

**Алгоритм (DENSITY_BASED):**

1. Параметры:

```
epsilon = median(field_radius) × 1.5  // Радиус соседства
min_points = 3                        // Минимум точек для кластера
```

2. Инициализация:

```
clusters = []
visited = Set()
noise = Set()
```

3. Для каждого узла:

```
if node_id in visited:
    continue

visited.add(node_id)
neighbors = FindNeighbors(node_id, level, radius=epsilon)

if len(neighbors) < min_points:
    noise.add(node_id)
    continue

// Создать новый кластер
cluster = Cluster { nodes: [node_id], level: level }
clusters.append(cluster)

// Расширить кластер
expand_cluster(cluster, neighbors, visited, epsilon, min_points)
```

4. return clusters

**Функция expand_cluster:**

```
queue = neighbors
while queue is not empty:
    current_id = queue.pop()
    
    if current_id in noise:
        noise.remove(current_id)
        cluster.nodes.append(current_id)
    
    if current_id in visited:
        continue
    
    visited.add(current_id)
    cluster.nodes.append(current_id)
    
    current_neighbors = FindNeighbors(current_id, level, radius=epsilon)
    
    if len(current_neighbors) ≥ min_points:
        queue.extend(current_neighbors)
```

**Возвращает:** Список кластеров

**Сложность:** O(N log N) в среднем

### 7.4 Алгоритм поиска путей в пространстве

#### SpatialPathfinding(start_id: uint32, goal_id: uint32, level: uint8) → List[uint32]

**Назначение:** Найти путь между двумя узлами через пространственно близких соседей

**Алгоритм (A* в пространстве):**

1. Инициализация:

```
open_set = PriorityQueue()
open_set.push((start_id, 0.0))  // (node_id, f_score)

came_from = Map()
g_score = Map { start_id: 0.0 }

goal_coords = decode_coordinates(GetNode(goal_id).coordinates[level])
```

2. Цикл поиска:

```
while open_set is not empty:
    current_id = open_set.pop()
    
    if current_id ≡ goal_id:
        return reconstruct_path(came_from, current_id)
    
    // Получить соседей
    neighbors = FindNeighbors(current_id, level, max_results=10)
    
    for (neighbor_id, distance) in neighbors:
        tentative_g = g_score[current_id] + distance
        
        if tentative_g < g_score.get(neighbor_id, ∞):
            came_from[neighbor_id] = current_id
            g_score[neighbor_id] = tentative_g
            
            // Эвристика: прямое расстояние до цели
            neighbor_coords = decode_coordinates(
                GetNode(neighbor_id).coordinates[level]
            )
            h = euclidean_distance(neighbor_coords, goal_coords)
            f = tentative_g + h
            
            open_set.push((neighbor_id, f))

3. return []  // Путь не найден
```

**Функция reconstruct_path:**

```
path = []
current = goal_id

while current in came_from:
    path.append(current)
    current = came_from[current]

path.append(start_id)
path.reverse()
return path
```

**Возвращает:** Список ID узлов, формирующих путь

**Сложность:** O(N log N) в худшем случае

### 7.5 Алгоритм идентификации границ полей

#### FieldBoundaryDetection(field: Field) → Polygon

**Назначение:** Определить границу семантического поля

**Алгоритм:**

1. Получить все узлы поля:

```
nodes = GetNodesInField(field)
```

2. Для каждого узла получить координаты:

```
points = [decode_coordinates(GetNode(id).coordinates[field.level]) for id in nodes]
```

3. Применить алгоритм Convex Hull (или Concave Hull для более точных границ):

```
boundary = convex_hull(points)
```

4. Опционально: расширить границу на average(field_radius):

```
expanded_boundary = expand_polygon(boundary, field.radius)
```

5. return expanded_boundary

**Возвращает:** Полигон, описывающий границу поля

**Сложность:** O(k log k) где k = количество узлов в поле

---

## 8. Производительность

### 8.1 Сложность операций

**Базовые операции:**

| Операция | Временная сложность | Пространственная сложность | Примечания |
|----------|---------------------|----------------------------|------------|
| GetNode | O(1) | O(1) | Hash map lookup |
| InsertNode | O(L log N) | O(L) | L = активные пространства |
| RemoveNode | O(L log N + E) | O(1) | E = количество связей |
| UpdateCoordinates | O(C log N) | O(1) | C = изменённые пространства |

**Пространственные запросы:**

| Операция | Временная сложность | Примечания |
|----------|---------------------|------------|
| FindNeighbors | O(log N + k) | k = количество соседей |
| KNearestNeighbors | O(log N + k log k) | Требует сортировки |
| RangeQuery | O(log N + k) | Зависит от индекса |
| Distance | O(1) | Простое вычисление |

**Сложные операции:**

| Операция | Временная сложность | Примечания |
|----------|---------------------|------------|
| IdentifyFields | O(N × S) | S = количество сэмплов |
| ClusterNodes | O(N log N) | DBSCAN-подобный |
| SpatialPathfinding | O(N log N) | A* в худшем случае |
| ComputeInfluence | O(log N + k) | k = узлов в радиусе |

### 8.2 Оценка памяти

**Базовое хранилище:**

```
Node storage:
    Hash map overhead: ~24-48 bytes per entry
    Total: N × (48 + key_size) ≈ N × 56 bytes

Для N = 1,000,000 узлов: ~56 MB
```

**Индексы:**

**k-d Tree:**

```
Node overhead: ~32 bytes per tree node
Total per space: N × 32 bytes
8 spaces: N × 256 bytes

Для N = 1,000,000: ~256 MB
```

**Octree:**

```
Более высокий overhead: N × 64-128 bytes per space
8 spaces: N × 512-1024 bytes

Для N = 1,000,000: ~512 MB - 1 GB
```

**Grid-based:**

```
Cell overhead: зависит от плотности
Sparse: ~N × 16 bytes (только непустые ячейки)
8 spaces: N × 128 bytes

Для N = 1,000,000: ~128 MB
```

**Итого для системы с 1М узлов:**

**Минимальная конфигурация (Grid-based индексы):**

```
Nodes: 56 MB
Indexes: 128 MB
Connections: ~40 MB (предполагая 0.01% sparse)
Overhead: ~50 MB
────────────────
Total: ~274 MB
```

**Полная конфигурация (k-d Trees + кэши):**

```
Nodes: 56 MB
Indexes: 256 MB
Connections: 40 MB
Field manager: 20 MB
Caches: 50 MB
Overhead: 50 MB
────────────────
Total: ~472 MB
```

### 8.3 Оптимизации

**Кэширование:**

```
Кэш 1: Горячие узлы (LRU)
    Size: 10,000 - 100,000 узлов
    Hit rate target: >90%
    Memory: ~10 MB

Кэш 2: Результаты FindNeighbors
    Key: (node_id, level, radius)
    Value: List[neighbor_id]
    Invalidation: при обновлении координат
    Memory: ~50 MB
    Hit rate target: >70%

Кэш 3: Field density map
    Сэмплированная карта плотности
    Update frequency: каждые 1000 операций
    Memory: ~20 MB
```

**Batch processing:**

```
Группировать операции:
    - Batch insert: минимизация lock contention
    - Batch update: амортизация rebalancing
    - Batch queries: использование SIMD

Выигрыш: 2-5x для массовых операций
```

**Lazy evaluation:**

```
Отложить тяжёлые операции:
    - IdentifyFields: вычислять по запросу
    - ClusterNodes: кэшировать результаты
    - Field boundaries: вычислять лениво

Экономия: избежать ненужных вычислений
```

**SIMD оптимизации:**

```
Vectorize distance calculations:
    - Вычислять расстояния для 4-8 узлов одновременно
    - Использовать SIMD для decode coordinates
    - Параллельные сравнения для фильтрации

Ускорение: 2-4x для пространственных запросов
```

### 8.4 Параллелизм

**Read-only операции (параллелизуемы):**

```
Могут выполняться одновременно:
    - GetNode
    - FindNeighbors
    - Distance
    - RangeQuery
    - ComputeInfluence

Стратегия: Read locks, множественный доступ
```

**Write операции (требуют синхронизации):**

```
Эксклюзивный доступ:
    - InsertNode
    - RemoveNode
    - UpdateCoordinates
    - Rebuild индекса

Стратегия: Write locks, очередь операций
```

**Партиционирование:**

```
Разделить Grid на партиции:
    - По пространствам (L1, L2, ... независимы)
    - По областям в пространстве (spatial partitioning)
    - По диапазонам ID узлов

Каждая партиция с отдельным lock
Выигрыш: N threads → N× throughput
```

**Lock-free структуры:**

```
Использовать для:
    - Grid-based индексов (concurrent hash maps)
    - Счётчиков статистики (atomic operations)
    - Read-mostly данных (RCU patterns)

Выигрыш: уменьшение contention
```

### 8.5 Benchmarking

**Ключевые метрики:**

```
Throughput:
    - Inserts per second
    - Queries per second
    - Updates per second

Latency:
    - p50, p95, p99 для FindNeighbors
    - Average query time
    - Max query time

Memory:
    - Bytes per node
    - Index overhead
    - Cache hit rates

Scalability:
    - Performance vs N (количество узлов)
    - Performance vs L (количество активных пространств)
    - Multi-thread scaling factor
```

**Целевые показатели:**

Для системы с 1M узлов на современном CPU (2024):

```
Inserts: >100,000 ops/sec
Queries (FindNeighbors): >500,000 ops/sec
Updates: >200,000 ops/sec

Latency (FindNeighbors):
    p50: <10 μs
    p95: <50 μs
    p99: <100 μs

Memory: <500 MB total
Cache hit rate: >85%
```

---

## 9. Интеграция с модулями

### 9.1 Token v2.0

**Зависимость Grid от Token:**

Grid требует от Token следующие поля:

**Обязательные:**

- `id: uint32`
- `coordinates: [8][3]int16`
- `flags:` включая `FLAG_ACTIVE`

**Опциональные (для полей):**

- `field_radius: float`
- `field_strength: float`
- `weight: float`

**Grid НЕ изменяет Token:**

- Grid только читает поля Token
- Изменение координат — ответственность внешней системы
- Grid обновляет индексы при изменениях

**Протокол взаимодействия:**

1. Внешняя система создаёт Token
2. Вызывает Grid.InsertNode(token)
3. Grid индексирует токен
4. При изменении координат:
   ```
   token.coordinates = new_coords
   Grid.UpdateNodeCoordinates(token.id, new_coords)
   ```
5. Grid обновляет индексы

### 9.2 Connection v1.0

**Grid использует Connection для:**

- Графовых запросов (обход связей)
- Информации о силовом взаимодействии между узлами
- Идентификации семантических отношений

**Grid НЕ управляет Connection:**

- Connection хранится отдельно (см. Connection v1.0 spec)
- Grid только запрашивает связи через API Connection

**Интеграция для полей:**

Connection.pull_strength и Connection.preferred_distance влияют на формирование полей:

**Алгоритм:**

1. Connection генерирует силы между узлами
2. Узлы мигрируют под действием сил
3. Миграция вызывает Grid.UpdateNodeCoordinates()
4. Grid обновляет индексы
5. Новые позиции → новое распределение плотности
6. Эмерджентно формируются поля

**API для интеграции:**

Grid предоставляет:

- `GetNode()` для получения координат узла
- `Distance()` для Connection вычисления сил
- `UpdateNodeCoordinates()` для применения миграции

Connection предоставляет:

- `GetConnections(node_id)` для получения связей узла
- `apply_force()` для вычисления сил (см. Connection spec)

### 9.3 Graph (будущий модуль)

Graph будет использовать Grid для:

- Пространственных эвристик при обходе
- Оптимизации поиска путей
- Визуализации графа в пространстве

**Примеры интеграции:**

**Graph.Traverse(start_id, goal_id):**

1. Использовать Grid.SpatialPathfinding() как эвристику
2. Комбинировать с логическим обходом по связям
3. Приоритизировать пространственно близкие узлы

**Graph.VisualizeCommunities():**

1. Использовать Grid.ClusterNodes() для группировки
2. Отобразить кластеры как визуальные области
3. Показать связи между кластерами

**Разделение ответственности:**

**Grid:**

- Пространственные запросы
- Координаты узлов
- Семантические поля

**Graph:**

- Топологический обход
- Алгоритмы на графах (PageRank, Community Detection)
- Логическая навигация по связям

### 9.4 FSC (будущая система энкодинга)

FSC будет использовать Grid как:

- Целевое пространство для проекции данных
- Систему координат для формализованных представлений

**Предполагаемая интеграция:**

```
FSC Encoder:
    Input: Raw data (text, image, audio)
    Output: FSC triplet {sign_vector, magnitude_vector, confidence}

Mapping to Grid: FSC triplet → 8-dimensional coordinates
```

**Алгоритм:**

1. FSC определяет октант (sign_vector)
2. FSC определяет позицию внутри октанта (magnitude_vector)
3. Создать Token с coordinates = f(FSC)
4. Grid.InsertNode(token)

Grid предоставляет:

- Стандартизованную систему координат
- Метрики расстояния для сравнения FSC представлений
- Механизм кластеризации для обнаружения паттернов

### 9.5 Внешние системы

**Визуализация:**

Grid экспортирует данные для визуализации:

- Export3DProjection(level: uint8) → List[(x, y, z, node_id)]
- ExportFieldBoundaries(level: uint8) → List[Polygon]
- ExportDensityMap(level: uint8) → VoxelGrid

Форматы: JSON, Binary, протоколы визуализации (VTK, Point Cloud)

**Persistence:**

Grid сериализуется вместе с Token и Connection:

- Grid.Save() → сохранить состояние индексов
- Grid.Load() → восстановить из файла

Опционально: incremental saves для больших систем

**Мониторинг:**

Grid экспортирует метрики:

- Prometheus/Grafana интеграция
- Real-time статистика (GetGridStatistics)
- Performance counters

---

## 10. Инварианты и валидация

### 10.1 Системные инварианты

**Инвариант 1: Уникальность ID**

Для любых двух узлов n1, n2 в Grid:

```
n1.id ≠ n2.id
```

**Проверка:**

```
assert len(node_storage) ≡ len(set(node.id for node in node_storage))
```

**Инвариант 2: Согласованность индексов**

Для каждого узла n в node_storage:

```
Для каждого пространства level где n.coordinates[level][0] ≠ 127:
    assert n.id in spatial_index[level]
```

Обратно:

```
Для каждого ID в spatial_index[level]:
    assert ID существует в node_storage
    assert node.coordinates[level][0] ≠ 127
```

**Инвариант 3: Валидность координат**

Для каждого узла n:

```
Для каждого пространства level:
    Для каждой оси axis in (x, y, z):
        coord = n.coordinates[level][axis]
        assert coord ≡ 127 OR -32767 ≤ coord ≤ 32767
```

**Инвариант 4: Валидность field параметров**

Для каждого узла n:

```
assert 0.0 ≤ n.field_radius ≤ 2.55
assert 0.0 ≤ n.field_strength ≤ 1.0
assert 0.0 ≤ n.weight ≤ 1.0
```

**Инвариант 5: Целостность связей**

Для каждой связи c (из Connection):

```
assert c.token_a_id существует в Grid
assert c.token_b_id существует в Grid
```

### 10.2 Операционные инварианты

**После InsertNode:**

Постусловия:

- node.id in node_storage
- Для каждого определённого пространства:
  node.id in spatial_index[level]
- Если field_radius > 0:
  node зарегистрирован в field_manager

**После RemoveNode:**

Постусловия:

- node.id not in node_storage
- Для всех пространств:
  node.id not in spatial_index[level]
- node не зарегистрирован в field_manager
- Все связи с node.id удалены

**После UpdateNodeCoordinates:**

Постусловия:

- node.coordinates = new_coordinates
- Индексы обновлены для изменённых пространств
- Неизменённые пространства: индексы не затронуты

### 10.3 Валидация операций

**Валидация InsertNode:**

Проверки перед вставкой:

1. node.id уникален

```
if node.id in node_storage:
    return Error("Duplicate ID")
```

2. Координаты валидны

```
for level in 0..7:
    validate_coordinates(node.coordinates[level])
```

3. Field параметры в диапазоне

```
assert 0.0 <= node.field_radius <= 2.55
assert 0.0 <= node.field_strength <= 1.0
```

4. Обязательные флаги установлены

```
// Специфичные проверки флагов
```

**Валидация FindNeighbors:**

Проверки перед запросом:

1. node_id существует

```
if node_id not in node_storage:
    return Error("Node not found")
```

2. level валиден

```
if not (0 <= level <= 7):
    return Error("Invalid level")
```

3. radius положителен

```
if radius is not None and radius <= 0:
    return Error("Invalid radius")
```

4. Узел присутствует в пространстве

```
if node.coordinates[level][0] == 127:
    return []  // Не ошибка, просто нет результатов
```

### 10.4 Периодическая валидация

**Integrity check:**

Периодически (например, каждые 10,000 операций):

```
validate_grid_integrity():
    1. Проверить все инварианты
    2. Сравнить node_storage с индексами
    3. Проверить отсутствие "потерянных" узлов
    4. Валидировать структуру индексов (глубина, balance)
    5. Логировать любые несоответствия
```

**Самовосстановление:**

При обнаружении нарушения инварианта:

1. Логировать детальную информацию
2. Попытаться исправить автоматически:
   - Reindex узлов
   - Удалить невалидные записи
   - Rebuild индексов
3. Если не удалось:
   - Пометить Grid как "degraded"
   - Требовать ручного вмешательства

### 10.5 Тестирование

**Unit тесты:**

Тестировать каждую операцию:

- InsertNode: различные сценарии
- RemoveNode: каскадное удаление
- UpdateCoordinates: частичные обновления
- FindNeighbors: граничные случаи

**Integration тесты:**

Тестировать взаимодействие:

- Grid + Token: корректная индексация
- Grid + Connection: обновление после миграции
- Concurrent operations: thread-safety

**Stress тесты:**

Проверить производительность:

- 1M узлов: скорость операций
- 10K одновременных запросов
- Массовые обновления координат

**Property-based тесты:**

Проверить инварианты:

- Quickcheck/Proptest: случайные операции
- После каждой операции: валидация инвариантов
- Обнаружение edge cases

---

## 11. Сериализация состояния

### 11.1 Формат файла Grid

**Структура файла:**

```
╔═══════════════════════════════════════════════════════════╗
║ GRID HEADER (128 bytes)                                   ║
╠═══════════════════════════════════════════════════════════╣
║ NODE STORAGE (variable)                                   ║
║ ┌─────────────────────────────────────────────────────┐   ║
║ │ Token #1 (64 bytes)                                 │   ║
║ ├─────────────────────────────────────────────────────┤   ║
║ │ Token #2 (64 bytes)                                 │   ║
║ ├─────────────────────────────────────────────────────┤   ║
║ │ ...                                                 │   ║
║ └─────────────────────────────────────────────────────┘   ║
╠═══════════════════════════════════════════════════════════╣
║ INDEX METADATA (variable)                                 ║
║ ┌─────────────────────────────────────────────────────┐   ║
║ │ Spatial Index L1 metadata                           │   ║
║ ├─────────────────────────────────────────────────────┤   ║
║ │ Spatial Index L2 metadata                           │   ║
║ ├─────────────────────────────────────────────────────┤   ║
║ │ ...                                                 │   ║
║ └─────────────────────────────────────────────────────┘   ║
╠═══════════════════════════════════════════════════════════╣
║ GRID FOOTER (64 bytes)                                    ║
╚═══════════════════════════════════════════════════════════╝
```

### 11.2 Grid Header

**Детальная структура (128 bytes):**

| Offset | Size | Type | Field | Description |
|--------|------|------|-------|-------------|
| 0 | 8 | char[8] | magic | "NGGRID02" (ASCII) |
| 8 | 2 | uint16 | version_major | Major version (2) |
| 10 | 2 | uint16 | version_minor | Minor version (0) |
| 12 | 2 | uint16 | version_patch | Patch version (0) |
| 14 | 2 | uint16 | endianness | 0x0102 = little-endian |
| 16 | 8 | uint64 | node_count | Total number of nodes |
| 24 | 4 | uint32 | created_timestamp | File creation time |
| 28 | 4 | uint32 | modified_timestamp | Last modification time |
| 32 | 4 | uint32 | checksum_type | 0=none, 1=CRC32, 2=SHA256 |
| 36 | 4 | uint32 | checksum_value | Checksum (if type=1) |
| 40 | 8 | uint64 | token_version_compat | Compatible Token version |
| 48 | 8 | uint64 | connection_version_compat | Compatible Connection version |
| 56 | 4 | uint32 | index_type | Index structure used |
| 60 | 4 | uint32 | grid_flags | Grid-level configuration flags |
| 64 | 8 | uint64 | index_metadata_offset | Offset to index metadata |
| 72 | 8 | uint64 | index_metadata_size | Size of index metadata |
| 80 | 48 | bytes | reserved | Reserved for future use |
| TOTAL | 128 bytes | | | |

**Index types:**

```
0x01: KD_TREE      - k-d trees for all spaces
0x02: OCTREE       - Octrees for all spaces
0x03: GRID_BASED   - Uniform grid for all spaces
0x04: MIXED        - Different structures per space (see metadata)
```

**Grid flags:**

```
Bit 0: COMPRESSED       - Node storage is compressed
Bit 1: ENCRYPTED        - Data is encrypted
Bit 2: INCLUDE_INDEXES  - Serialized indexes included
Bit 3: INCLUDE_FIELDS   - Field information included
Bit 4-31: Reserved
```

### 11.3 Node Storage Section

**Формат:**

- Последовательность Token v2.0 структур (64 bytes каждая)
- Порядок: По возрастанию node.id (для эффективной загрузки)
- Количество: grid_header.node_count

**Если COMPRESSED:**

- Вся секция сжата как единый блок
- Алгоритм: LZ4 или Zstd
- Распаковывается перед чтением Token

### 11.4 Index Metadata Section

**Для каждого из 8 пространств:**

**Spatial Index Metadata (32 bytes):**

| Offset | Size | Type | Field |
|--------|------|------|-------|
| 0 | 1 | uint8 | level (0-7) |
| 1 | 1 | uint8 | index_type |
| 2 | 2 | uint16 | flags |
| 4 | 4 | uint32 | node_count |
| 8 | 8 | uint64 | index_data_offset |
| 16 | 8 | uint64 | index_data_size |
| 24 | 8 | uint64 | reserved |
| TOTAL | 32 bytes | | |

Всего для 8 пространств: 256 bytes

**Сериализованные индексы (опционально):**

Если grid_flags & INCLUDE_INDEXES:

- После metadata идут сериализованные структуры индексов
- Формат зависит от index_type:
  - KD_TREE: предварительный обход дерева
  - OCTREE: breadth-first обход
  - GRID_BASED: hash map ячеек
- Позволяет быструю загрузку без пересчёта индексов

### 11.5 Grid Footer

**Структура (64 bytes):**

| Offset | Size | Type | Field | Description |
|--------|------|------|-------|-------------|
| 0 | 8 | char[8] | magic_end | "GRIDEND\0" |
| 8 | 8 | uint64 | file_size | Total file size in bytes |
| 16 | 4 | uint32 | data_checksum | Checksum всех данных |
| 20 | 4 | uint32 | validation_flags | Validation status |
| 24 | 40 | bytes | reserved | Reserved |
| TOTAL | 64 bytes | | | |

**Validation flags:**

```
Bit 0: NODES_VALID         - All nodes passed validation
Bit 1: INDEXES_VALID       - Indexes consistent with nodes
Bit 2: CHECKSUM_VALID      - Checksums match
Bit 3: COMPATIBLE_VERSIONS - Token/Connection versions compatible
Bit 4-31: Reserved
```

### 11.6 Операции сериализации

#### Save(filepath: string, options: SaveOptions)

**Назначение:** Сохранить состояние Grid в файл

**Параметры:**

- filepath: Путь к файлу
- options:
  ```
  {
      include_indexes: bool,      // Сериализовать индексы
      compression: CompressionType,
      encryption: EncryptionType
  }
  ```

**Алгоритм:**

1. Создать header:

```
header.magic = "NGGRID02"
header.version = (2, 0, 0)
header.node_count = len(node_storage)
header.created_timestamp = original_creation_time
header.modified_timestamp = current_time
header.index_type = determine_index_type()
header.grid_flags = compute_flags(options)
```

2. Записать header (128 bytes)

3. Записать узлы:

```
nodes = sorted(node_storage.values(), key=lambda n: n.id)
if options.compression:
    compressed = compress(serialize_all(nodes))
    write(compressed)
else:
    for node in nodes:
        write(node.pack())  // 64 bytes
```

4. Если options.include_indexes:

```
write_index_metadata()
for level in 0..7:
    serialized = spatial_index[level].serialize()
    write(serialized)
```

5. Записать footer:

```
footer.magic_end = "GRIDEND\0"
footer.file_size = current_position
footer.data_checksum = compute_checksum(all_data)
footer.validation_flags = validate_all()
write(footer)
```

6. Flush и закрыть файл

**Сложность:** O(N log N) для сортировки + O(N) для записи

#### Load(filepath: string) → Grid

**Назначение:** Загрузить состояние Grid из файла

**Алгоритм:**

1. Открыть файл

2. Прочитать и валидировать header:

```
header = read(128)
assert header.magic == "NGGRID02"
assert compatible_version(header.version)
assert compatible_token_version(header.token_version_compat)
```

3. Создать новый Grid:

```
grid = Grid::new()
```

4. Загрузить узлы:

```
if header.grid_flags & COMPRESSED:
    compressed_data = read(до index_metadata_offset)
    nodes_data = decompress(compressed_data)
    tokens = deserialize_all(nodes_data)
else:
    tokens = []
    for i in 0..header.node_count:
        token_bytes = read(64)
        token = Token::unpack(token_bytes)
        tokens.append(token)

// Вставить все узлы
for token in tokens:
    grid.InsertNode(token)
```

5. Если header.grid_flags & INCLUDE_INDEXES:

```
// Загрузить предпостроенные индексы
metadata = read_index_metadata()

for level in 0..7:
    offset = metadata[level].index_data_offset
    size = metadata[level].index_data_size
    seek(offset)
    index_data = read(size)
    grid.spatial_index[level] = deserialize_index(index_data)
```

else:

```
// Перестроить индексы
grid.rebuild_all_indexes()
```

6. Прочитать и валидировать footer:

```
seek(end - 64)
footer = read(64)
assert footer.magic_end == "GRIDEND\0"
assert footer.file_size == actual_file_size

if header.checksum_type != 0:
    assert footer.data_checksum == compute_checksum(data)
```

7. return grid

**Сложность:**

- С индексами: O(N)
- Без индексов: O(N log N) для rebuild

### 11.7 Incremental saves

Для больших систем (N > 1M узлов):

**Стратегия: Write-Ahead Log (WAL)**

**Структура:**

```
base.grid              - Полный snapshot
changes_001.wal        - Инкрементальные изменения
changes_002.wal
...
```

**WAL формат:**

```
[Operation Type (1 byte)][Data (variable)]
```

**Types:**

```
0x01: INSERT_NODE      [Token: 64 bytes]
0x02: REMOVE_NODE      [node_id: 4 bytes]
0x03: UPDATE_COORDS    [node_id: 4 bytes][coords: 48 bytes]
```

**Загрузка:**

1. Загрузить base.grid
2. Применить все WAL файлы по порядку
3. Опционально: consolidate в новый base

**Consolidation trigger:**

- Количество WAL > THRESHOLD (например, 100)
- Размер WAL > SIZE_THRESHOLD (например, 100 MB)
- По расписанию (например, ежедневно)

### 11.8 Partial загрузка

Для очень больших Grid (N > 10M):

**Memory-mapped файлы:**

**Алгоритм:**

1. mmap файл Grid
2. Создать "lazy" node_storage:
   - ID → file_offset mapping
   - Загружать Token только при обращении
3. Rebuild индексов в памяти (или mmap индексы)
4. Операции работают с mmap регионом

**Преимущества:**

- Быстрый старт (не нужно загружать всё)
- OS управляет paging
- Меньше памяти

**Недостатки:**

- Медленнее для случайного доступа
- Требует read-only или сложной синхронизации

### 11.9 Экспорт в другие форматы

**JSON (для отладки/визуализации):**

```json
{
    "version": "2.0.0",
    "node_count": 1000,
    "spaces": [
        {
            "level": 0,
            "name": "L1_Physical",
            "nodes": [
                {
                    "id": 42,
                    "coordinates": [10.5, 20.3, 1.5],
                    "field_radius": 1.0,
                    "field_strength": 0.8
                }
            ]
        }
    ],
    "fields": [
        {
            "level": 7,
            "center": [0.5, 0.3, 0.2],
            "radius": 0.8,
            "node_count": 150
        }
    ]
}
```

**Point Cloud (для 3D визуализации):**

- Форматы: PLY, PCD, XYZ
- Экспорт координат для выбранного пространства
- Включает метаданные (цвет по field_strength, размер по field_radius)

**Graph formats (для Graph модуля):**

- Форматы: GraphML, GML, DOT
- Узлы = Token ID
- Рёбра = из Connection
- Атрибуты узлов = coordinates, field параметры

---

## Приложения

### A. Константы и параметры

**Системные константы:**

```rust
// Размерности
const NUM_SPACES: usize = 8;
const COORDS_PER_SPACE: usize = 3;

// Границы координат
const COORD_MIN: i16 = -32767;
const COORD_MAX: i16 = 32767;
const COORD_UNDEFINED: i16 = 127;

// Масштабы (из Token v2.0)
const SCALE_PHYSICAL: u16 = 100;
const SCALE_SENSORY: u16 = 10000;
const SCALE_MOTOR: u16 = 1000;
const SCALE_EMOTIONAL: u16 = 10000;
const SCALE_COGNITIVE: u16 = 10000;
const SCALE_SOCIAL: u16 = 10000;
const SCALE_TEMPORAL_XY: u16 = 100;
const SCALE_TEMPORAL_Z: u16 = 1000;
const SCALE_ABSTRACT: u16 = 10000;

// Индексы
const KD_TREE_MAX_LEAF_SIZE: usize = 20;
const OCTREE_MAX_DEPTH: u32 = 12;
const OCTREE_MAX_NODES_PER_LEAF: usize = 20;
const GRID_LOAD_FACTOR: f32 = 0.75;

// Поля
const FIELD_DENSITY_THRESHOLD: f32 = 0.5;
const MIN_FIELD_SIZE: usize = 3;
const FIELD_SAMPLE_DENSITY: usize = 1000;

// Производительность
const CACHE_SIZE_HOT_NODES: usize = 10000;
const CACHE_SIZE_NEIGHBOR_QUERIES: usize = 5000;
const BATCH_SIZE_OPTIMAL: usize = 1000;

// Валидация
const INTEGRITY_CHECK_INTERVAL: usize = 10000;
const MAX_COORDINATE_EPSILON: f32 = 0.001;
```

### B. Типы данных (Rust)

**Основные типы:**

```rust
// Координаты в одном пространстве
type SpaceCoords = (f32, f32, f32);

// Координаты во всех пространствах
type MultiSpaceCoords = [Option<SpaceCoords>; 8];

// ID узла
type NodeId = u32;

// Уровень пространства
type SpaceLevel = u8;  // 0-7

// Результат поиска соседей
type Neighbor = (NodeId, f32);  // (ID, расстояние)

// Поле
struct Field {
    level: SpaceLevel,
    center: SpaceCoords,
    radius: f32,
    strength: f32,
    node_count: usize,
    total_weight: f32,
}

// Статистика Grid
struct GridStats {
    total_nodes: usize,
    nodes_per_space: [usize; 8],
    avg_field_radius: f32,
    avg_field_strength: f32,
    total_fields: usize,
    memory_usage_bytes: u64,
}
```

### C. Глоссарий терминов

**Grid (Сетка)** - Фундаментальная координатная система, определяющая 8-мерное пространство

**Space (Пространство)** - Одно из 8 независимых 3D координатных пространств (L1-L8)

**Node (Узел)** - Token, присутствующий в Grid с определёнными координатами

**Spatial Index (Пространственный индекс)** - Структура данных для быстрого поиска узлов по координатам

**Semantic Field (Семантическое поле)** - Область высокой плотности узлов, возникающая эмерджентно

**field_radius** - Радиус зоны влияния узла

**field_strength** - Интенсивность влияния узла на окружающее пространство

**Sparse (Разреженный)** - Характеристика Grid, где заполнена малая доля возможных координат

**Multi-space presence** - Свойство узла существовать одновременно в нескольких пространствах

**Influence** - Воздействие узла на точку в пространстве через field параметры

**Density** - Количество узлов в единице объёма пространства

### D. Ссылки

**Связанные спецификации:**

- Token v2.0 Specification
- Connection v1.0 Specification
- Graph Module (будущая спецификация)
- FSC Encoding System (будущая спецификация)

**Алгоритмы и структуры данных:**

- k-d Trees (Bentley, 1975)
- Octrees (Meagher, 1980)
- DBSCAN Clustering (Ester et al., 1996)
- A* Pathfinding (Hart et al., 1968)

**Теоретические основы:**

- Semantic Spaces (Gärdenfors, 2000)
- Self-Organizing Maps (Kohonen, 1982)
- Spatial Indexing (Samet, 1990)

### E. История изменений

**Version 2.0.0 (2025-10-21)**

- Первый официальный релиз спецификации Grid
- Определение 8 координатных пространств
- Система семантических полей
- Пространственная индексация (k-d trees, octrees, grid-based)
- Интеграция с Token v2.0 и Connection v1.0
- Сериализация состояния Grid
- Детальные алгоритмы поиска и кластеризации

**Future Considerations (для v2.1+):**

- Динамическая адаптация структуры индексов
- GPU-ускоренные пространственные запросы
- Distributed Grid для масштабирования
- Advanced field dynamics (слияние, распад, эволюция)
- Integration с FSC encoding system

---

## Заключение

Grid Specification v2.0 определяет фундаментальную координатную систему NeuroGraph OS — 8-мерное семантическое пространство, в котором существуют и взаимодействуют все информационные единицы системы.

**Ключевые достижения спецификации:**

✅ **Первичность координат** — Grid определяет пространство, Token фиксируют позиции

✅ **Многомерность** — 8 независимых ортогональных пространств

✅ **Семантические поля** — эмерджентные структуры через field_radius/strength

✅ **Эффективная индексация** — sparse структуры для быстрого поиска

✅ **Гибридная природа** — пространственная + графовая модель

✅ **Масштабируемость** — от 10³ до 10⁷ узлов

✅ **Интеграция** — чистые интерфейсы с Token и Connection

**Grid как основа:**

Grid предоставляет:

- Универсальную систему отсчёта для всех модулей
- Механизм самоорганизации через поля
- Эффективный поиск через пространственные индексы
- Семантическую структуру через многомерность

**Практическое применение:**

Данная спецификация предоставляет полную техническую основу для реализации Grid на Rust с интеграцией в NeuroGraph OS.

---

**Версия документа:** 2.0.0  
**Дата:** 2025-10-21  
**Статус:** Official Specification  
**Авторы:** NeuroGraph OS Team  
**Зависимости:** Token v2.0, Connection v1.0

**END OF SPECIFICATION**
