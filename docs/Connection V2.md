# Connection Specification v1.0 — Official Documentation

**Статус:** Official Specification  
**Версия:** 1.0.0  
**Дата:** 2025-10-21  
**Совместимость:** NeuroGraph OS Token v2.0  
**Целевые языки:** Rust, C++, Python, любой системный язык

---

## Оглавление

1. Обзор и философия
2. Бинарная структура
3. Поля данных
4. Типы связей
5. Уровни активности
6. Флаги состояния
7. Динамические параметры
8. Временные метки
9. Семантика и поведение
10. Физическая модель
11. Хранение и индексация
12. Жизненный цикл
13. Валидация
14. Производительность
15. Совместимость
16. Формат сериализации

---

## 1. Обзор и философия

### 1.1 Определение

**Connection** — это сущность, представляющая направленное или ненаправленное отношение между двумя токенами в NeuroGraph OS. Связь является **физической силой**, которая влияет на координаты токенов в многомерном пространстве состояний и формирует топологию семантических полей.

### 1.2 Философия дизайна

Connection спроектирована с учётом следующих принципов:

- **Физическая сущность** — связь активно влияет на позиции токенов через силы притяжения/отталкивания
- **Эволюционирующая структура** — связь усиливается или ослабевает в зависимости от частоты использования
- **Типизированное отношение** — каждая связь имеет семантический тип (синоним, причина, правило и т.д.)
- **Sparse существование** — связь материализуется только при необходимости, не все возможные связи существуют физически
- **Многоуровневая природа** — связь может действовать избирательно на разных уровнях 8-мерного пространства
- **Компактное представление** — фиксированный размер 32 байта для эффективного хранения и обработки
- **Память о прошлом** — связь хранит историю активаций и временные метки

### 1.3 Роль в системе

Connection выполняет три ключевые функции:

1. **Формирование топологии** — связи определяют структуру семантического пространства
2. **Механизм самоорганизации** — через взаимодействие связей и токенов возникают поля смыслов
3. **Координация модулей** — связи служат общей картой для всех когнитивных модулей системы

### 1.4 Отличие от Token

|Аспект|Token|Connection|
|---|---|---|
|Размер|64 байта|32 байта|
|Сущность|Дискретная единица информации|Отношение между единицами|
|Координаты|Имеет позицию в 8 пространствах|Влияет на позиции других|
|Идентификация|Уникальный ID|Пара ID токенов|
|Жизненный цикл|Относительно стабильный|Динамичный, зависит от активации|

---

## 2. Бинарная структура

### 2.1 Общая структура (32 байта)

Connection представляет собой плотно упакованную структуру фиксированного размера:

```
Offset  Size    Type      Field Name          Description
------  ------  --------  ------------------  ---------------------------
0       4       uint32    token_a_id          ID первого токена
4       4       uint32    token_b_id          ID второго токена
8       1       uint8     connection_type     Тип связи (0-255)
9       1       uint8     rigidity            Жёсткость связи (0-255)
10      1       uint8     active_levels       Битмаска активных уровней
11      1       uint8     flags               Флаги состояния
12      4       uint32    activation_count    Счётчик активаций
16      4       float32   pull_strength       Сила притяжения/отталкивания
20      4       float32   preferred_distance  Желаемое расстояние
24      4       uint32    created_at          Unix timestamp создания
28      4       uint32    last_activation     Unix timestamp последней активации
------  ------  --------  ------------------  ---------------------------
TOTAL:  32 bytes
```

### 2.2 Выравнивание (Alignment)

Структура спроектирована с учётом естественного выравнивания:

- uint32 поля выравнены по 4-байтной границе
- float32 поля выравнены по 4-байтной границе
- uint8 поля сгруппированы для минимизации padding

**Гарантия:** структура не требует дополнительного padding при естественном выравнивании.

### 2.3 Порядок байтов (Endianness)

**Стандарт:** Little-endian (LE) для всех многобайтовых полей.

**Обоснование:** Совместимость с большинством современных архитектур (x86, x86-64, ARM в режиме LE).

**Требование к реализации:** При сериализации/десериализации всегда использовать явное указание порядка байтов, не полагаясь на нативный порядок платформы.

### 2.4 Формат упаковки

Для языков с поддержкой struct packing:

```
Format string (C-style):   "<IIBBBBIffII"
Format string (Rust):      Use #[repr(C)] with explicit field order
Format string (Python):    struct.pack('<2I 4B I 2f 2I', ...)
```

Символы формата:

- `I` = uint32 (4 bytes, unsigned)
- `B` = uint8 (1 byte, unsigned)
- `f` = float32 (4 bytes, IEEE 754)
- `<` = little-endian

---

## 3. Поля данных

### 3.1 TOKEN_A_ID (offset 0, 4 bytes)

**Тип:** uint32  
**Диапазон:** 1 до 4,294,967,295  
**Семантика:** Идентификатор первого токена в связи

**Правила:**

- Значение 0 зарезервировано и означает "отсутствие токена" (недопустимо в валидной связи)
- В канонической форме `token_a_id < token_b_id` для избежания дублирования
- ID должен существовать в системе Token
- ID может содержать метаданные согласно спецификации Token v2.0

**Извлечение метаданных из ID:**

```
local_id      = token_a_id & 0x00FFFFFF  (биты 0-23)
entity_type   = (token_a_id >> 24) & 0x0F (биты 24-27)
domain        = (token_a_id >> 28) & 0x0F (биты 28-31)
```

### 3.2 TOKEN_B_ID (offset 4, 4 bytes)

**Тип:** uint32  
**Диапазон:** 1 до 4,294,967,295  
**Семантика:** Идентификатор второго токена в связи

**Правила:**

- Значение 0 зарезервировано (недопустимо в валидной связи)
- В канонической форме `token_b_id > token_a_id`
- ID должен существовать в системе Token
- `token_a_id != token_b_id` (самосвязи запрещены в v1.0)

**Каноническая нормализация:**

```
При создании связи с ID1 и ID2:
if ID1 > ID2:
    swap(ID1, ID2)
token_a_id = ID1
token_b_id = ID2
```

### 3.3 CONNECTION_TYPE (offset 8, 1 byte)

**Тип:** uint8  
**Диапазон:** 0x00 до 0xFF (256 типов)  
**Семантика:** Категория семантического отношения между токенами

**Назначение:** Определяет природу связи и влияет на:

- Значение `preferred_distance` по умолчанию
- Поведение при самоорганизации
- Интерпретацию связи когнитивными модулями
- Приоритет при конфликтах

Подробная классификация типов в разделе 4. Типы связей.

### 3.4 RIGIDITY (offset 9, 1 byte)

**Тип:** uint8  
**Диапазон:** 0 до 255  
**Кодирование:** Значение 0-255 представляет диапазон 0.0-1.0

**Декодирование:**

```
rigidity_float = rigidity_uint8 / 255.0
```

**Кодирование:**

```
rigidity_uint8 = clamp(round(rigidity_float * 255.0), 0, 255)
```

**Семантика жёсткости:**

|uint8|float|Категория|Характеристика|
|---|---|---|---|
|0-51|0.0-0.2|Очень мягкая|Слабые ассоциации, легко нарушаются|
|52-102|0.2-0.4|Мягкая|Контекстно-зависимые связи|
|103-153|0.4-0.6|Средняя|Устойчивые связи|
|154-204|0.6-0.8|Жёсткая|Редко нарушаемые связи|
|205-255|0.8-1.0|Очень жёсткая|Аксиомы, правила, законы|

**Влияние на динамику:**

- Жёсткость умножается на силу притяжения при вычислении воздействия на координаты
- Высокая жёсткость = связь сильнее сопротивляется изменению расстояния между токенами
- Низкая жёсткость = связь допускает бо́льшую вариативность расстояния

**Особые значения:**

- `0` (0.0) — связь не оказывает влияния на координаты (информационная связь)
- `255` (1.0) — максимальная жёсткость (аксиоматические правила)

### 3.5 ACTIVE_LEVELS (offset 10, 1 byte)

**Тип:** uint8 (битовая маска)  
**Диапазон:** 0x00 до 0xFF  
**Семантика:** Определяет, на каких из 8 уровней пространства активна связь

**Структура битов:**

```
Bit 7    Bit 6    Bit 5    Bit 4    Bit 3    Bit 2    Bit 1    Bit 0
L8       L7       L6       L5       L4       L3       L2       L1
Abstract Temporal Social  Cognitive Emotional Motor   Sensory  Physical
```

**Операции с битами:**

```
Проверка активности на уровне N:
    is_active = (active_levels & (1 << N)) != 0

Установка активности на уровне N:
    active_levels |= (1 << N)

Снятие активности с уровня N:
    active_levels &= ~(1 << N)

Проверка активности на нескольких уровнях:
    is_active_on_any = (active_levels & mask) != 0
    is_active_on_all = (active_levels & mask) == mask
```

**Предопределённые маски:**

```
ALL_LEVELS          = 0xFF  // 11111111
NO_LEVELS           = 0x00  // 00000000
PHYSICAL_ONLY       = 0x01  // 00000001
ABSTRACT_ONLY       = 0x80  // 10000000
PHYSICAL_MOTOR      = 0x05  // 00000101
EMOTIONAL_SOCIAL    = 0x28  // 00101000
COGNITIVE_ABSTRACT  = 0x90  // 10010000
TEMPORAL_ABSTRACT   = 0xC0  // 11000000
LOWER_LEVELS        = 0x0F  // 00001111 (L1-L4)
UPPER_LEVELS        = 0xF0  // 11110000 (L5-L8)
```

**Правила:**

- Значение `0x00` (нет активных уровней) допустимо для неактивных связей, но такие связи не участвуют в вычислениях
- Значение `0xFF` означает, что связь универсальна и действует на всех уровнях
- Для большинства связей рекомендуется активировать только релевантные уровни

### 3.6 FLAGS (offset 11, 1 byte)

**Тип:** uint8 (битовые флаги)  
**Диапазон:** 0x00 до 0xFF  
**Семантика:** Состояние и режимы работы связи

**Структура битов:**

```
Bit 7    Bit 6    Bit 5      Bit 4      Bit 3    Bit 2       Bit 1          Bit 0
USER_2   USER_1   DECAYING   REINFORCED MUTABLE  PERSISTENT  BIDIRECTIONAL  ACTIVE
```

**Системные флаги (биты 0-3):**

- **Bit 0: ACTIVE (0x01)**
    
    - Связь активна и участвует в вычислениях
    - Неактивные связи игнорируются при обновлении координат
    - По умолчанию: установлен при создании
- **Bit 1: BIDIRECTIONAL (0x02)**
    
    - Связь действует в обе стороны симметрично
    - Если не установлен: связь может иметь направление (token_a → token_b)
    - Большинство связей являются двунаправленными
- **Bit 2: PERSISTENT (0x04)**
    
    - Связь должна быть сохранена при сериализации
    - Защищает связь от автоматического удаления при очистке
    - Используется для важных правил и аксиом
- **Bit 3: MUTABLE (0x08)**
    
    - Связь может изменять свои параметры динамически
    - Если не установлен: связь статична (например, правила математики)
    - По умолчанию: установлен для обучаемых связей

**Динамические флаги (биты 4-5):**

- **Bit 4: REINFORCED (0x10)**
    
    - Связь была недавно усилена активацией
    - Временный флаг, может быть сброшен при затухании
    - Используется для приоритизации активных связей
- **Bit 5: DECAYING (0x20)**
    
    - Связь затухает от неиспользования
    - Кандидат на удаление при cleanup
    - Устанавливается автоматически при длительном отсутствии активаций

**Пользовательские флаги (биты 6-7):**

- **Bit 6: USER_1 (0x40)**
    
    - Зарезервирован для приложений
    - Семантика определяется пользователем
- **Bit 7: USER_2 (0x80)**
    
    - Зарезервирован для приложений
    - Семантика определяется пользователем

**Типичные комбинации:**

```
ACTIVE | BIDIRECTIONAL | MUTABLE           = 0x0B  // Обычная обучаемая связь
ACTIVE | PERSISTENT                        = 0x05  // Правило
ACTIVE | BIDIRECTIONAL | PERSISTENT        = 0x07  // Аксиома
ACTIVE | REINFORCED                        = 0x11  // Недавно активированная
DECAYING                                   = 0x20  // Затухающая (неактивная)
```

### 3.7 ACTIVATION_COUNT (offset 12, 4 bytes)

**Тип:** uint32  
**Диапазон:** 0 до 4,294,967,295  
**Семантика:** Количество раз, когда связь была активирована (использована)

**Назначение:**

- Метрика важности связи
- Критерий для принятия решений о сохранении/удалении
- Основа для эволюции параметров связи

**Поведение:**

- Инициализируется значением 0 при создании
- Увеличивается на 1 при каждой активации
- Не уменьшается автоматически
- Может быть сброшен явно при реорганизации системы

**Пороговые значения (рекомендуемые):**

```
THRESHOLD_EPHEMERAL     = 5        // Ниже этого — эфемерная связь
THRESHOLD_TEMPORARY     = 50       // Временная связь
THRESHOLD_STABLE        = 500      // Стабильная связь
THRESHOLD_PERMANENT     = 5000     // Постоянная связь
THRESHOLD_CORE          = 50000    // Ядро системы
```

**Использование в алгоритмах:**

- Cleanup: удалять связи с `activation_count < THRESHOLD` и большим возрастом
- Reinforcement: усиливать параметры при превышении порогов
- Prioritization: связи с высоким счётчиком имеют приоритет при конфликтах

**Overflow:** При достижении максимального значения (4,294,967,295) дальнейшие инкременты игнорируются или происходит насыщение.

### 3.8 PULL_STRENGTH (offset 16, 4 bytes)

**Тип:** float32 (IEEE 754 single precision)  
**Диапазон:** Теоретически ±3.4e38, практически рекомендуется -10.0 до +10.0  
**Семантика:** Интенсивность силы притяжения (положительная) или отталкивания (отрицательная)

**Интерпретация знака:**

- `pull_strength > 0` — притяжение (токены стремятся приблизиться)
- `pull_strength = 0` — нейтральная связь (не влияет на координаты)
- `pull_strength < 0` — отталкивание (токены стремятся отдалиться)

**Типичные значения:**

```
Отталкивание:
  -1.0 до -0.5     // Сильное отталкивание (антонимы, несовместимые концепты)
  -0.5 до -0.1     // Слабое отталкивание

Нейтральность:
   0.0             // Информационная связь без физического влияния

Притяжение:
   0.1 до 0.3      // Слабое притяжение (ассоциации)
   0.3 до 0.7      // Среднее притяжение (семантические связи)
   0.7 до 1.0      // Сильное притяжение (синонимы, правила)
   1.0 до 5.0      // Очень сильное притяжение (аксиомы)
```

**Физический смысл:** В физической модели pull_strength определяет коэффициент в формуле силы:

```
F = (preferred_distance - current_distance) × rigidity × pull_strength
```

**Особые случаи:**

- `NaN` или `Inf` — недопустимо, связь считается невалидной
- `|pull_strength| > 10.0` — экстремальное значение, требует осторожности
- `pull_strength = 0.0` — связь может использоваться для маркировки отношений без физического влияния

### 3.9 PREFERRED_DISTANCE (offset 20, 4 bytes)

**Тип:** float32 (IEEE 754 single precision)  
**Диапазон:** 0.0 до практически любого положительного значения  
**Семантика:** Желаемое расстояние между токенами в пространстве соответствующего уровня

**Интерпретация:**

- `preferred_distance = 0.0` — токены должны совпадать (идентичность)
- `preferred_distance > 0.0` — токены должны находиться на заданном расстоянии
- Связь "стремится" удержать токены на этом расстоянии через силу притяжения/отталкивания

**Типичные значения по типам связей:**

```
SYNONYM:              0.0 - 0.1    // Практически совпадают
HYPERNYM/HYPONYM:     0.3 - 0.5    // Близко, но различимо
ASSOCIATION:          0.5 - 1.5    // Среднее расстояние
CAUSE/EFFECT:         0.8 - 2.0    // Зависит от прямоты связи
ANTONYM:              2.0 - 5.0    // Далеко друг от друга
UNRELATED:            > 5.0        // Максимальное разделение
```

**Единицы измерения:** Расстояние измеряется в единицах соответствующего пространства:

- L1 (Physical): метры
- L2-L8: нормализованные единицы (обычно -1.0 до +1.0 по каждой оси)

**Взаимодействие с текущим расстоянием:**

```
if current_distance < preferred_distance:
    // Сила отталкивания (если pull_strength > 0)
    // Токены слишком близко, нужно отдалить
    
if current_distance > preferred_distance:
    // Сила притяжения (если pull_strength > 0)
    // Токены слишком далеко, нужно приблизить
    
if current_distance == preferred_distance:
    // Равновесие, сила = 0
```

**Особые случаи:**

- `preferred_distance < 0.0` — недопустимо, связь невалидна
- `NaN` или `Inf` — недопустимо
- `preferred_distance` очень большое (> 100) — может указывать на ошибку конфигурации

### 3.10 CREATED_AT (offset 24, 4 bytes)

**Тип:** uint32  
**Диапазон:** 0 до 4,294,967,295  
**Семантика:** Unix timestamp (секунды с 1970-01-01 00:00:00 UTC) создания связи

**Временной диапазон:**

```
Минимум: 0           = 1970-01-01 00:00:00 UTC
Максимум: 4294967295 = 2106-02-07 06:28:15 UTC
```

**Назначение:**

- Определение абсолютного возраста связи
- Фильтрация связей по времени создания
- Аудит и отладка

**Поведение:**

- Устанавливается один раз при создании связи
- Не изменяется в течение жизни связи
- Используется для вычисления возраста: `age = current_time - created_at`

**Особые случаи:**

- `created_at = 0` — может указывать на неинициализированную связь или связь, созданную в 1970
- `created_at > current_time` — невалидно, указывает на ошибку (время в будущем)

### 3.11 LAST_ACTIVATION (offset 28, 4 bytes)

**Тип:** uint32  
**Диапазон:** 0 до 4,294,967,295  
**Семантика:** Unix timestamp последней активации связи

**Назначение:**

- Определение времени с последнего использования
- Критерий для cleanup (удаление неиспользуемых связей)
- Обнаружение затухающих связей

**Поведение:**

- Инициализируется значением `created_at` при создании
- Обновляется каждый раз при активации связи
- Используется для вычисления времени неактивности: `stale_time = current_time - last_activation`

**Взаимодействие с другими полями:**

```
Инварианты:
    last_activation >= created_at     // Всегда
    last_activation <= current_time   // Должно быть
    
При активации:
    last_activation = current_time
    activation_count += 1
    flags |= REINFORCED
    flags &= ~DECAYING
```

**Использование в алгоритмах:**

```
Определение устаревших связей:
    is_stale = (current_time - last_activation) > STALE_THRESHOLD
    
Определение кандидатов на удаление:
    should_remove = is_stale && 
                   activation_count < MIN_COUNT &&
                   !(flags & PERSISTENT)
```

**Особые случаи:**

- `last_activation = 0` — может указывать на неинициализированное состояние
- `last_activation < created_at` — невалидно, указывает на ошибку
- `last_activation > current_time` — невалидно, время в будущем

---

## 4. Типы связей

### 4.1 Классификация

Типы связей организованы в иерархические категории по старшим битам байта:

```
0x00-0x0F   Семантические отношения
0x10-0x1F   Каузальные отношения
0x20-0x2F   Временные отношения
0x30-0x3F   Пространственные отношения
0x40-0x4F   Логические отношения
0x50-0x5F   Ассоциативные связи
0x60-0x6F   Структурные связи
0x70-0x7F   Функциональные связи
0x80-0x8F   Эмоциональные связи
0x90-0x9F   Правила и метафоры
0xA0-0xAF   Динамические связи
0xB0-0xEF   Зарезервировано
0xF0-0xFF   Пользовательские типы
```

### 4.2 Семантические отношения (0x00-0x0F)

**0x00: UNDEFINED**

- Неопределённый тип связи
- Используется как значение по умолчанию
- Не рекомендуется для продакшн-систем
- Параметры по умолчанию: rigidity=0.5, preferred_distance=1.0

**0x01: SYNONYM**

- Синонимичные токены (означают одно и то же)
- Рекомендуемая жёсткость: 0.7-0.9
- Рекомендуемое расстояние: 0.0-0.1
- Активные уровни: L8 (Abstract)
- Примеры: "кот" ↔ "кошка", "автомобиль" ↔ "машина"

**0x02: ANTONYM**

- Антонимы (противоположные по значению)
- Рекомендуемая жёсткость: 0.6-0.8
- Рекомендуемое расстояние: 2.0-5.0
- pull_strength: может быть отрицательным (отталкивание)
- Активные уровни: L8 (Abstract)
- Примеры: "горячий" ↔ "холодный", "день" ↔ "ночь"

**0x03: HYPERNYM**

- Гипероним (родовое понятие)
- Направление: token_a (вид) → token_b (род)
- Рекомендуемая жёсткость: 0.7-0.9
- Рекомендуемое расстояние: 0.3-0.5
- Активные уровни: L8 (Abstract), часто L5 (Cognitive)
- Примеры: "кот" → "млекопитающее", "роза" → "цветок"

**0x04: HYPONYM**

- Гипоним (видовое понятие)
- Направление: token_a (род) → token_b (вид)
- Обратное к HYPERNYM
- Рекомендуемая жёсткость: 0.7-0.9
- Рекомендуемое расстояние: 0.3-0.5
- Активные уровни: L8 (Abstract), L5 (Cognitive)

**0x05: MERONYM**

- Мероним (часть-целое)
- Направление: token_a (часть) →
- token_b (целое)

- Рекомендуемая жёсткость: 0.6-0.8
- Рекомендуемое расстояние: 0.4-0.7
- Активные уровни: L1 (Physical), L8 (Abstract)
- Примеры: "колесо" → "автомобиль", "палец" → "рука"

**0x06: HOLONYM**

- Холоним (целое-часть)
- Направление: token_a (целое) → token_b (часть)
- Обратное к MERONYM
- Рекомендуемая жёсткость: 0.6-0.8
- Рекомендуемое расстояние: 0.4-0.7
- Активные уровни: L1 (Physical), L8 (Abstract)

**0x07-0x0F: RESERVED**

- Зарезервировано для будущих семантических типов

### 4.3 Каузальные отношения (0x10-0x1F)

**0x10: CAUSE**

- Причинно-следственная связь
- Направление: token_a (причина) → token_b (следствие)
- Рекомендуемая жёсткость: 0.6-0.8
- Рекомендуемое расстояние: 0.5-1.5
- Активные уровни: L7 (Temporal), L8 (Abstract)
- Примеры: "дождь" → "мокрая земля", "нагрев" → "расширение"

**0x11: EFFECT**

- Следствие-причина (обратное к CAUSE)
- Направление: token_a (следствие) → token_b (причина)
- Рекомендуемая жёсткость: 0.6-0.8
- Рекомендуемое расстояние: 0.5-1.5
- Активные уровни: L7 (Temporal), L8 (Abstract)

**0x12: ENABLES**

- Делает возможным, создаёт условия
- Направление: token_a → token_b (A позволяет B)
- Рекомендуемая жёсткость: 0.5-0.7
- Рекомендуемое расстояние: 0.8-1.5
- Активные уровни: L5 (Cognitive), L8 (Abstract)
- Примеры: "ключ" → "открытие двери", "знание" → "понимание"

**0x13: PREVENTS**

- Предотвращает, препятствует
- Направление: token_a → token_b (A предотвращает B)
- Рекомендуемая жёсткость: 0.5-0.7
- Рекомендуемое расстояние: 2.0-3.0
- pull_strength: может быть отрицательным
- Активные уровни: L5 (Cognitive), L8 (Abstract)
- Примеры: "вакцина" → "болезнь", "зонт" → "промокание"

**0x14: REQUIRES**

- Требует, необходимо для
- Направление: token_a → token_b (A требует B)
- Рекомендуемая жёсткость: 0.7-0.9
- Рекомендуемое расстояние: 0.3-0.8
- Активные уровни: L5 (Cognitive), L8 (Abstract)
- Примеры: "огонь" → "кислород", "чтение" → "грамотность"

**0x15-0x1F: RESERVED**

- Зарезервировано для будущих каузальных типов

### 4.4 Временные отношения (0x20-0x2F)

**0x20: TEMPORAL_BEFORE**

- Происходит до, предшествует
- Направление: token_a → token_b (A до B)
- Рекомендуемая жёсткость: 0.6-0.8
- Рекомендуемое расстояние: зависит от временного интервала
- Активные уровни: L7 (Temporal)
- Примеры: "рассвет" → "день", "детство" → "юность"

**0x21: TEMPORAL_AFTER**

- Происходит после, следует за
- Направление: token_a → token_b (A после B)
- Обратное к TEMPORAL_BEFORE
- Рекомендуемая жёсткость: 0.6-0.8
- Активные уровни: L7 (Temporal)

**0x22: TEMPORAL_DURING**

- Происходит во время
- Направление: token_a → token_b (A происходит во время B)
- Рекомендуемая жёсткость: 0.5-0.7
- Рекомендуемое расстояние: 0.0-0.5
- Активные уровни: L7 (Temporal)
- Примеры: "обед" → "рабочий день", "цветение" → "весна"

**0x23: TEMPORAL_OVERLAPS**

- Пересекается во времени
- Симметричная связь
- Рекомендуемая жёсткость: 0.4-0.6
- Рекомендуемое расстояние: 0.3-0.8
- Активные уровни: L7 (Temporal)

**0x24-0x2F: RESERVED**

- Зарезервировано для будущих временных типов

### 4.5 Пространственные отношения (0x30-0x3F)

**0x30: SPATIAL_NEAR**

- Рядом в пространстве
- Рекомендуемая жёсткость: 0.4-0.6
- Рекомендуемое расстояние: 0.5-2.0
- Активные уровни: L1 (Physical)
- Примеры: "стол" ↔ "стул", "дом" ↔ "сад"

**0x31: SPATIAL_FAR**

- Далеко в пространстве
- Рекомендуемая жёсткость: 0.3-0.5
- Рекомендуемое расстояние: 5.0-10.0
- pull_strength: может быть отрицательным
- Активные уровни: L1 (Physical)

**0x32: SPATIAL_INSIDE**

- Внутри, содержится в
- Направление: token_a → token_b (A внутри B)
- Рекомендуемая жёсткость: 0.6-0.8
- Рекомендуемое расстояние: 0.0-0.3
- Активные уровни: L1 (Physical), L8 (Abstract)
- Примеры: "мебель" → "комната", "орган" → "тело"

**0x33: SPATIAL_OUTSIDE**

- Снаружи, вне
- Направление: token_a → token_b (A снаружи B)
- Обратное к SPATIAL_INSIDE
- Рекомендуемая жёсткость: 0.5-0.7
- Рекомендуемое расстояние: 1.0-3.0
- Активные уровни: L1 (Physical)

**0x34: SPATIAL_ADJACENT**

- Смежный, примыкающий
- Рекомендуемая жёсткость: 0.5-0.7
- Рекомендуемое расстояние: 0.1-0.5
- Активные уровни: L1 (Physical)
- Примеры: "стена" ↔ "стена", "страна" ↔ "граничащая страна"

**0x35-0x3F: RESERVED**

- Зарезервировано для будущих пространственных типов

### 4.6 Логические отношения (0x40-0x4F)

**0x40: LOGICAL_AND**

- Логическое И (конъюнкция)
- Оба токена должны быть истинны одновременно
- Рекомендуемая жёсткость: 0.8-1.0
- Рекомендуемое расстояние: 0.2-0.5
- Активные уровни: L5 (Cognitive), L8 (Abstract)

**0x41: LOGICAL_OR**

- Логическое ИЛИ (дизъюнкция)
- Хотя бы один из токенов истинен
- Рекомендуемая жёсткость: 0.7-0.9
- Рекомендуемое расстояние: 0.5-1.0
- Активные уровни: L5 (Cognitive), L8 (Abstract)

**0x42: LOGICAL_NOT**

- Логическое НЕ (отрицание)
- Направление: token_a → token_b (NOT B)
- Рекомендуемая жёсткость: 0.8-1.0
- Рекомендуемое расстояние: 2.0-4.0
- pull_strength: обычно отрицательный
- Активные уровни: L8 (Abstract)

**0x43: LOGICAL_IMPLIES**

- Логическая импликация (A → B)
- Направление: token_a → token_b (если A, то B)
- Рекомендуемая жёсткость: 0.7-0.9
- Рекомендуемое расстояние: 0.5-1.0
- Активные уровни: L5 (Cognitive), L8 (Abstract)

**0x44: LOGICAL_EQUIV**

- Логическая эквивалентность (A ↔ B)
- Симметричная связь
- Рекомендуемая жёсткость: 0.8-1.0
- Рекомендуемое расстояние: 0.1-0.3
- Активные уровни: L8 (Abstract)

**0x45-0x4F: RESERVED**

- Зарезервировано для будущих логических типов

### 4.7 Ассоциативные связи (0x50-0x5F)

**0x50: ASSOCIATION**

- Общая ассоциация без конкретной семантики
- Наиболее гибкий и универсальный тип
- Рекомендуемая жёсткость: 0.3-0.6
- Рекомендуемое расстояние: 0.5-2.0
- Активные уровни: любые, обычно L8 (Abstract)
- Примеры: "пляж" ↔ "лето", "кофе" ↔ "утро"

**0x51: COOCCURRENCE**

- Частая совместная встречаемость
- Статистическая связь
- Рекомендуемая жёсткость: пропорциональна частоте
- Рекомендуемое расстояние: обратно пропорционально частоте
- Активные уровни: зависит от контекста
- Формула жёсткости: `rigidity = min(0.9, probability × 2)`

**0x52: SIMILARITY**

- Похожесть, сходство
- Симметричная связь
- Рекомендуемая жёсткость: 0.4-0.7
- Рекомендуемое расстояние: 0.3-0.8
- Активные уровни: L2 (Sensory), L8 (Abstract)
- Примеры: "апельсин" ↔ "мандарин", "бег" ↔ "ходьба"

**0x53: CONTRAST**

- Контраст, различие
- Симметричная связь
- Рекомендуемая жёсткость: 0.4-0.6
- Рекомендуемое расстояние: 1.5-3.0
- Активные уровни: L8 (Abstract)
- Примеры: "город" ↔ "деревня", "теория" ↔ "практика"

**0x54-0x5F: RESERVED**

- Зарезервировано для будущих ассоциативных типов

### 4.8 Структурные связи (0x60-0x6F)

**0x60: HIERARCHY**

- Иерархическая связь (общая)
- Направление: token_a → token_b (A подчинён B)
- Рекомендуемая жёсткость: 0.6-0.8
- Рекомендуемое расстояние: 0.5-1.0 на уровень иерархии
- Активные уровни: L5 (Cognitive), L6 (Social), L8 (Abstract)

**0x61: COMPOSITION**

- Композиция (сильная связь часть-целое)
- Направление: token_a → token_b (A составляет B)
- Части не могут существовать независимо от целого
- Рекомендуемая жёсткость: 0.7-0.9
- Рекомендуемое расстояние: 0.2-0.5
- Активные уровни: L1 (Physical), L8 (Abstract)
- Примеры: "сердце" → "организм", "процессор" → "компьютер"

**0x62: AGGREGATION**

- Агрегация (слабая связь часть-целое)
- Направление: token_a → token_b (A агрегируется в B)
- Части могут существовать независимо
- Рекомендуемая жёсткость: 0.4-0.6
- Рекомендуемое расстояние: 0.5-1.0
- Активные уровни: L8 (Abstract)
- Примеры: "студент" → "университет", "сотрудник" → "компания"

**0x63: DEPENDENCY**

- Зависимость
- Направление: token_a → token_b (A зависит от B)
- Рекомендуемая жёсткость: 0.6-0.8
- Рекомендуемое расстояние: 0.3-0.7
- Активные уровни: зависит от контекста
- Примеры: "приложение" → "библиотека", "эффект" → "условие"

**0x64-0x6F: RESERVED**

- Зарезервировано для будущих структурных типов

### 4.9 Функциональные связи (0x70-0x7F)

**0x70: FUNCTION**

- Общая функциональная связь
- Направление: token_a → token_b (A функционально связано с B)
- Рекомендуемая жёсткость: 0.5-0.7
- Рекомендуемое расстояние: 0.5-1.0
- Активные уровни: L5 (Cognitive), L8 (Abstract)

**0x71: INSTRUMENT**

- Инструментальная связь (делается с помощью)
- Направление: token_a → token_b (A — инструмент для B)
- Рекомендуемая жёсткость: 0.6-0.8
- Рекомендуемое расстояние: 0.4-0.8
- Активные уровни: L1 (Physical), L3 (Motor), L8 (Abstract)
- Примеры: "молоток" → "забивание гвоздей", "ручка" → "письмо"

**0x72: AGENT**

- Агентивная связь (кто делает)
- Направление: token_a → token_b (A — агент действия B)
- Рекомендуемая жёсткость: 0.6-0.8
- Рекомендуемое расстояние: 0.3-0.7
- Активные уровни: L3 (Motor), L5 (Cognitive), L8 (Abstract)
- Примеры: "повар" → "готовка", "учитель" → "обучение"

**0x73: PATIENT**

- Пациентивная связь (над чем делается)
- Направление: token_a → token_b (A — объект действия B)
- Рекомендуемая жёсткость: 0.6-0.8
- Рекомендуемое расстояние: 0.3-0.7
- Активные уровни: L8 (Abstract)
- Примеры: "дерево" → "рубка", "текст" → "чтение"

**0x74-0x7F: RESERVED**

- Зарезервировано для будущих функциональных типов

### 4.10 Эмоциональные связи (0x80-0x8F)

**0x80: AFFINITY**

- Симпатия, притяжение
- Рекомендуемая жёсткость: 0.4-0.7
- Рекомендуемое расстояние: 0.3-0.8
- pull_strength: положительный
- Активные уровни: L4 (Emotional), L6 (Social)
- Примеры: "дружба" ↔ "радость", "любимое место" ↔ "умиротворение"

**0x81: AVERSION**

- Антипатия, отталкивание
- Рекомендуемая жёсткость: 0.4-0.7
- Рекомендуемое расстояние: 2.0-4.0
- pull_strength: отрицательный
- Активные уровни: L4 (Emotional), L6 (Social)
- Примеры: "страх" ↔ "опасность", "неприязнь" ↔ "конфликт"

**0x82: EMPATHY**

- Эмпатическая связь
- Рекомендуемая жёсткость: 0.5-0.7
- Рекомендуемое расстояние: 0.2-0.5
- Активные уровни: L4 (Emotional), L6 (Social)
- Примеры: "грусть другого" ↔ "собственная грусть"

**0x83-0x8F: RESERVED**

- Зарезервировано для будущих эмоциональных типов

### 4.11 Правила и метафоры (0x90-0x9F)

**0x90: RULE_AXIOM**

- Аксиома (самоочевидная истина)
- Рекомендуемая жёсткость: 1.0 (максимальная)
- Рекомендуемое расстояние: 0.0 (точное совпадение)
- pull_strength: максимальный (1.0)
- Активные уровни: ALL_LEVELS
- flags: PERSISTENT | ACTIVE
- Примеры: фундаментальные принципы логики

**0x91: RULE_MATH**

- Математическое правило
- Рекомендуемая жёсткость: 1.0
- Рекомендуемое расстояние: 0.0
- pull_strength: 1.0
- Активные уровни: L5 (Cognitive), L8 (Abstract)
- flags: PERSISTENT | ACTIVE
- Примеры: "2+2" ↔ "4", "sin²+cos²" ↔ "1"

**0x92: RULE_PHYSICS**

- Физическое правило/закон
- Рекомендуемая жёсткость: 0.9-1.0
- Рекомендуемое расстояние: 0.0-0.1
- pull_strength: 0.8-1.0
- Активные уровни: L1 (Physical), L3 (Motor), L8 (Abstract)
- flags: PERSISTENT | ACTIVE
- Примеры: "F" ↔ "ma", "E" ↔ "mc²"

**0x93: RULE_LOGIC**

- Логическое правило
- Рекомендуемая жёсткость: 0.9-1.0
- Рекомендуемое расстояние: 0.0-0.1
- Активные уровни: L5 (Cognitive), L8 (Abstract)
- flags: PERSISTENT | ACTIVE
- Примеры: правила вывода, законы логики

**0x94: METAPHOR**

- Метафорическая связь
- Рекомендуемая жёсткость: 0.2-0.5
- Рекомендуемое расстояние: 1.0-3.0
- Активные уровни: L8 (Abstract), L4 (Emotional)
- Примеры: "время" ↔ "река", "жизнь" ↔ "путешествие"

**0x95: ANALOGY**

- Аналогия (структурное сходство)
- Рекомендуемая жёсткость: 0.3-0.6
- Рекомендуемое расстояние: 0.5-1.5
- Активные уровни: L5 (Cognitive), L8 (Abstract)
- Примеры: "атом" ↔ "солнечная система", "мозг" ↔ "компьютер"

**0x96-0x9F: RESERVED**

- Зарезервировано для будущих правил и метафор

### 4.12 Динамические связи (0xA0-0xAF)

**0xA0: ACTIVATION**

- Взаимная активация
- Активация одного токена повышает вероятность активации другого
- Рекомендуемая жёсткость: 0.4-0.7
- Рекомендуемое расстояние: 0.5-1.0
- pull_strength: положительный
- Активные уровни: зависит от контекста
- Используется в нейронных моделях

**0xA1: INHIBITION**

- Взаимное подавление
- Активация одного токена подавляет другой
- Рекомендуемая жёсткость: 0.4-0.7
- Рекомендуемое расстояние: 2.0-4.0
- pull_strength: отрицательный
- Активные уровни: зависит от контекста
- Используется в конкурентных моделях

**0xA2: MODULATION**

- Модуляция
- Один токен модулирует эффект другого
- Рекомендуемая жёсткость: 0.3-0.6
- Рекомендуемое расстояние: 0.5-1.5
- Активные уровни: зависит от контекста

**0xA3: AMPLIFICATION**

- Усиление
- Один токен усиливает эффект другого
- Рекомендуемая жёсткость: 0.4-0.7
- Рекомендуемое расстояние: 0.3-0.8
- pull_strength: положительный
- Активные уровни: зависит от контекста

**0xA4-0xAF: RESERVED**

- Зарезервировано для будущих динамических типов

### 4.13 Пользовательские типы (0xF0-0xFF)

**0xF0-0xFE: CUSTOM_1 ... CUSTOM_15**

- Пользовательские типы связей
- Семантика определяется приложением
- Параметры по умолчанию не определены
- Рекомендуется документировать семантику в метаданных системы

**0xFF: RESERVED**

- Зарезервировано для системных нужд

---

## 5. Уровни активности

### 5.1 Соответствие уровням Token

Connection может быть активна на одном или нескольких из 8 уровней пространства, определённых в спецификации Token v2.0:

```
Bit 0: L1 - Physical     (Физическое пространство)
Bit 1: L2 - Sensory      (Сенсорное пространство)
Bit 2: L3 - Motor        (Моторное пространство)
Bit 3: L4 - Emotional    (Эмоциональное пространство)
Bit 4: L5 - Cognitive    (Когнитивное пространство)
Bit 5: L6 - Social       (Социальное пространство)
Bit 6: L7 - Temporal     (Темпоральное пространство)
Bit 7: L8 - Abstract     (Абстрактное пространство)
```

### 5.2 Семантика активности на уровнях

**Активная связь на уровне** означает, что:

- Связь влияет на координаты токенов в этом уровне пространства
- При вычислении сил учитывается расстояние между токенами в этом уровне
- Связь участвует в формировании полей смыслов на этом уровне

**Неактивная связь на уровне** означает, что:

- Связь не влияет на координаты в этом уровне
- Расстояние в этом уровне игнорируется для данной связи
- Связь не участвует в самоорганизации на этом уровне

### 5.3 Рекомендации по выбору уровней

**Однуровневые связи:**

- Используются для специфичных отношений
- L1 (Physical): пространственные отношения в физическом мире
- L8 (Abstract): чисто семантические отношения без физической компоненты

**Многоуровневые связи:**

- Используются для комплексных отношений
- Причинность: L7 (Temporal) + L8 (Abstract)
- Эмоциональная ассоциация: L2 (Sensory) + L4 (Emotional)
- Функциональные связи: L3 (Motor) + L5 (Cognitive) + L8 (Abstract)

**Универсальные связи:**

- active_levels = 0xFF (все уровни)
- Используются для фундаментальных правил и аксиом
- Должны применяться осторожно

### 5.4 Взаимодействие с Token

При вычислении силы от связи:

```
Для каждого уровня L в active_levels:
    1. Извлечь координаты token_a и token_b на уровне L
    2. Вычислить расстояние между ними
    3. Вычислить силу притяжения/отталкивания
    4. Применить силу к координатам обоих токенов на уровне L
```

Если связь не активна на уровне L, токены на этом уровне не взаимодействуют через данную связь.

---

## 6. Флаги состояния

### 6.1 Системные флаги (0x0F)

**ACTIVE (0x01)**

- **Назначение:** Основной флаг активности
- **Поведение при установке:** Связь участвует во всех вычислениях
- **Поведение при сбросе:** Связь игнорируется, но сохраняется в памяти
- **По умолчанию:** Установлен при создании
- **Взаимодействие:** Может быть временно сброшен для отладки или тестирования

**BIDIRECTIONAL (0x02)**

- **Назначение:** Симметричность связи
- **Поведение при установке:** Сила действует одинаково в обоих направлениях
- **Поведение при сбросе:** Связь может иметь асимметрию (направленность)
- **По умолчанию:** Зависит от типа связи
- **Примеры:**
    - Установлен: SYNONYM, ASSOCIATION, SIMILARITY
    - Сброшен: HYPERNYM, CAUSE, AGENT

**PERSISTENT (0x04)**

- **Назначение:** Защита от автоматического удаления
- **Поведение при установке:** Связь сохраняется даже при cleanup
- **Поведение при сбросе:** Связь может быть удалена при неиспользовании
- **По умолчанию:** Сброшен для обучаемых связей, установлен для правил
- **Использование:** Обязательно для RULE_* типов

**MUTABLE (0x08)**

- **Назначение:** Возможность изменения параметров
- **Поведение при установке:** Параметры (rigidity, preferred_distance) могут эволюционировать
- **Поведение при сбросе:** Параметры статичны
- **По умолчанию:** Установлен для ассоциативных связей, сброшен для правил
- **Примеры:**
    - Установлен: ASSOCIATION, COOCCURRENCE
    - Сброшен: RULE_MATH, RULE_PHYSICS

### 6.2 Динамические флаги (0x30)

**REINFORCED (0x10)**

- **Назначение:** Маркер недавнего усиления
- **Установка:** Автоматически при активации связи
- **Сброс:** Через определённый период времени или при затухании
- **Использование:** Приоритизация "горячих" связей при обработке
- **Жизненный цикл:** Временный флаг

**DECAYING (0x20)**

- **Назначение:** Маркер затухания от неиспользования
- **Установка:** Автоматически когда `(current_time - last_activation) > DECAY_THRESHOLD`
- **Сброс:** При следующей активации связи
- **Использование:** Идентификация кандидатов на удаление
- **Жизненный цикл:** Временный флаг
- **Взаимодействие:** Несовместим с REINFORCED (взаимоисключающие)

### 6.3 Пользовательские флаги (0xC0)

**USER_1 (0x40)**

- **Назначение:** Расширение функциональности приложением
- **Семантика:** Определяется пользователем
- **Примеры использования:**
    - Маркировка связей для визуализации
    - Отметка связей определённого модуля
    - Временные метки для алгоритмов

**USER_2 (0x80)**

- **Назначение:** Второй пользовательский флаг
- **Семантика:** Определяется пользователем
- **Независимость:** Не зависит от USER_1

### 6.4 Типичные комбинации флагов

```
Обучаемая ассоциация:
    ACTIVE | BIDIRECTIONAL | MUTABLE = 0x0B

Математическое правило:
    ACTIVE | PERSISTENT = 0x05

Фундаментальная аксиома:
    ACTIVE | BIDIRECTIONAL | PERSISTENT = 0x07

Направленная каузальная связь:
    ACTIVE | MUTABLE = 0x09

Недавно активированная связь:
    ACTIVE | REINFORCED | MUTABLE = 0x19

Затухающая связь (кандидат на удаление):
    DECAYING = 0x20 (ACTIVE сброшен)

Временно отключённая связь (отладка):
    PERSISTENT | MUTABLE = 0x0C (ACTIVE сброшен)
```

### 6.5 Правила взаимодействия флагов

**Конфликты:**

- REINFORCED и DECAYING не должны быть установлены одновременно
- При установке REINFORCED автоматически сбрасывается DECAYING
- При установке DECAYING автоматически сбрасывается REINFORCED

**Зависимости:**

- PERSISTENT рекомендуется для всех RULE_* типов
- MUTABLE не рекомендуется для RULE_* типов
- ACTIVE должен быть установлен для участия в вычислениях

**Валидация:**

```
Предупреждения (warnings):
    - PERSISTENT && MUTABLE (может быть валидно, но необычно)
    - !PERSISTENT && connection_type >= 0x90 && connection_type <= 0x9F (правило без персистентности)

Ошибки (errors):
    - REINFORCED && DECAYING (логически противоречиво)
```

---

## 7. Динамические параметры

### 7.1 Модель силового взаимодействия

Connection реализует физическую модель силового взаимодействия между токенами, основанную на следующей формуле:

```
Для каждого активного уровня L:
    
    current_distance = euclidean_distance(token_a.coords[L], token_b.coords[L])
    
    delta = preferred_distance - current_distance
    
    force_magnitude = delta × rigidity × pull_strength
    
    direction = normalize(token_b.coords[L] - token_a.coords[L])
    
    force_on_token_a = direction × force_magnitude
    force_on_token_b = -direction × force_magnitude  // Третий закон Ньютона
```

### 7.2 Интерпретация параметров

**pull_strength (коэффициент силы):**

- Определяет интенсивность взаимодействия
- Положительные значения → притяжение
- Отрицательные значения → отталкивание
- Нулевое значение → информационная связь без физического эффекта

**preferred_distance (целевое расстояние):**

- Точка равновесия системы
- При `current_distance = preferred_distance` сила равна нулю
- При `current_distance < preferred_distance` сила стремится увеличить расстояние
- При `current_distance > preferred_distance` сила стремится уменьшить расстояние

**rigidity (коэффициент жёсткости):**

- Определяет "упругость" связи
- Высокая жёсткость → сильное сопротивление отклонению от preferred_distance
- Низкая жёсткость → допускает большую вариативность

### 7.3 Энергетическая модель

Connection можно рассматривать как потенциальную энергию:

```
Потенциальная энергия связи:
    U = 0.5 × rigidity × pull_strength × (current_distance - preferred_distance)²

Свойства:
    - Минимум энергии при current_distance = preferred_distance
    - Жёсткость определяет крутизну потенциальной ямы
    - pull_strength определяет масштаб энергии
```

Система стремится минимизировать суммарную потенциальную энергию всех связей.

### 7.4 Поведение различных типов связей

**Притягивающие связи (pull_strength > 0):**

```
Пример: SYNONYM
    rigidity = 0.9
    preferred_distance = 0.05
    pull_strength = 0.8

Если токены находятся на расстоянии 0.5:
    delta = 0.05 - 0.5 = -0.45
    force_magnitude = -0.45 × 0.9 × 0.8 ≈ -0.324
    
    → Сильная сила притяжения, стремящаяся сблизить токены
```

**Отталкивающие связи (pull_strength < 0):**

```
Пример: ANTONYM
    rigidity = 0.7
    preferred_distance = 3.0
    pull_strength = -0.5

Если токены находятся на расстоянии 1.0:
    delta = 3.0 - 1.0 = 2.0
    force_magnitude = 2.0 × 0.7 × (-0.5) = -0.7
    
    → Сила отталкивания, стремящаяся удалить токены друг от друга
```

**Балансирующие связи:**

```
Пример: HIERARCHY
    rigidity = 0.8
    preferred_distance = 0.5
    pull_strength = 0.6

Система стремится удержать токены на расстоянии 0.5:
    - Если ближе → отталкивание
    - Если дальше → притяжение
    - Точно на 0.5 → равновесие
```

### 7.5 Динамическая эволюция параметров

Для связей с флагом MUTABLE параметры могут эволюционировать:

**Усиление при активации:**

```
При каждой активации (если MUTABLE):
    
    Увеличение жёсткости:
        rigidity_new = min(255, rigidity_old + DELTA_RIGIDITY)
    
    Увеличение силы:
        pull_strength_new = min(MAX_STRENGTH, pull_strength_old × AMPLIFICATION_FACTOR)
    
    Уменьшение предпочитаемого расстояния (для притягивающих связей):
        if pull_strength > 0:
            preferred_distance_new = max(MIN_DISTANCE, 
                                        preferred_distance_old × COMPRESSION_FACTOR)
```

**Затухание при неиспользовании:**

```
Периодически (если MUTABLE && DECAYING):
    
    Уменьшение жёсткости:
        rigidity_new = max(0, rigidity_old - DECAY_RIGIDITY)
    
    Уменьшение силы:
        pull_strength_new = pull_strength_old × DECAY_FACTOR
    
    Если rigidity < THRESHOLD_MIN:
        → Связь помечается на удаление
```

**Рекомендуемые константы:**

```
DELTA_RIGIDITY = 1          // Прирост за активацию
AMPLIFICATION_FACTOR = 1.01 // 1% усиления
COMPRESSION_FACTOR = 0.99   // 1% сжатия
DECAY_FACTOR = 0.995        // 0.5% затухания
THRESHOLD_MIN = 10          // Минимальная жёсткость для существования
```

### 7.6 Численная стабильность

При реализации необходимо учитывать:

**Ограничение величины силы:**

```
Максимальная сила за шаг:
    force_magnitude = clamp(force_magnitude, -MAX_FORCE, MAX_FORCE)
    
Рекомендуемое MAX_FORCE = 1.0 для стабильности
```

**Временной шаг (dt):**

```
Применение силы к координатам:
    coord_new = coord_old + force × dt
    
Рекомендуемое dt = 0.001 - 0.01 для стабильной интеграции
Слишком большое dt → нестабильность, колебания
Слишком малое dt → медленная сходимость
```

**Проверка на NaN и Inf:**

```
После каждого вычисления:
    if isnan(force) || isinf(force):
        force = 0.0
        log_warning("Invalid force detected")
```

---

## 8. Временные метки

### 8.1 Unix Timestamp

Оба поля timestamp (created_at и last_activation) используют стандарт Unix timestamp:

```
Формат: uint32
Значение: Количество секунд с 1970-01-01 00:00:00 UTC
Диапазон: 0 до 4,294,967,295
Временной охват: 1970-01-01 до 2106-02-07
```

### 8.2 Жизненный цикл временных меток

**При создании связи:**

```
current_time = get_unix_timestamp()
created_at = current_time
last_activation = current_time
activation_count = 0
```

**При активации связи:**

```
current_time = get_unix_timestamp()
last_activation = current_time
activation_count += 1
flags |= REINFORCED
flags &= ~DECAYING
```

**При периодической проверке:**

```
current_time = get_unix_timestamp()
age = current_time - created_at
stale_time = current_time - last_activation

if stale_time > DECAY_THRESHOLD:
    flags |= DECAYING
    flags &= ~REINFORCED
```

### 8.3 Вычисляемые метрики

**Абсолютный возраст:**

```
age_seconds = current_time - created_at
age_minutes = age_seconds / 60
age_hours = age_seconds / 3600
age_days = age_seconds / 86400
```

**Время с последней активации:**

```
stale_seconds = current_time - last_activation
stale_minutes = stale_seconds / 60
stale_hours = stale_seconds / 3600
```

**Частота активации:**

```
if age_seconds > 0:
    activation_rate = activation_count / age_seconds  // активаций в секунду
    activations_per_minute = activation_rate × 60
    activations_per_hour = activation_rate × 3600
```

**Индекс свежести:**

```
freshness = 1.0 / (1.0 + stale_seconds / FRESHNESS_SCALE)

где FRESHNESS_SCALE — константа (например, 3600 секунд)

Свойства:
    - freshness = 1.0 сразу после активации
    - freshness → 0 при длительном отсутствии активаций
    - freshness = 0.5 когда stale_seconds = FRESHNESS_SCALE
```

### 8.4 Пороговые значения

**Рекомендуемые временные пороги:**

```
THRESHOLD_FRESH = 60          // 1 минута — свежая связь
THRESHOLD_RECENT = 300        // 5 минут — недавняя
THRESHOLD_ACTIVE = 3600       // 1 час — активная
THRESHOLD_STALE = 86400       // 1 день — устаревшая
THRESHOLD_OLD = 604800        // 1 неделя — старая
THRESHOLD_ANCIENT = 2592000   // 30 дней — древняя
```

**Классификация по возрасту:**

```
if stale_seconds < THRESHOLD_FRESH:
    status = "FRESH"
elif stale_seconds < THRESHOLD_RECENT:
    status = "RECENT"
elif stale_seconds < THRESHOLD_ACTIVE:
    status = "ACTIVE"
elif stale_seconds < THRESHOLD_STALE:
    status = "STALE"
elif stale_seconds < THRESHOLD_OLD:
    status = "OLD"
else:
    status = "ANCIENT"
```

### 8.5 Обработка переполнения

**Проблема 2038 года:**

- Unix timestamp достигнет максимума int32 (2,147,483,647) 19 января 2038
- uint32 позволяет продлить до 2106 года
- Для систем с длительным жизненным циклом требуется стратегия миграции

**Стратегии:**

1. Использование относительных timestamp (смещение от базовой даты)
2. Периодическое обновление базовой даты системы
3. Миграция на 64-битные timestamp в будущих версиях

**Обработка некорректных значений:**

```
Валидация при десериализации:
    if created_at > current_time:
        log_error("created_at in future")
        created_at = current_time
    
    if last_activation > current_time:
        log_error("last_activation in future")
        last_activation = current_time
    
    if last_activation < created_at:
        log_error("last_activation before created_at")
        last_activation = created_at
```

---

## 9. Семантика и поведение

### 9.1 Каноническая форма

Для избежания дублирования связей используется каноническая форма:

**Правило упорядочивания:**

```
Для любой пары токенов (A, B):
    if A.id > B.id:
        swap(A, B)
    
    Connection(token_a_id=A.id, token_b_id=B.id)
```

**Следствия:**

- Всегда `token_a_id < token_b_id`
- Связь (42, 100) эквивалентна попытке создать (100, 42)
- Ключ хранения: `(min(id1, id2), max(id1, id2))`

**Направленные связи:** Для типов с направлением (HYPERNYM, CAUSE и т.д.) направление кодируется в connection_type, а не в порядке ID:

```
"кот" → "млекопитающее" (HYPERNYM)
token_a_id = id("кот")         // меньший ID
token_b_id = id("млекопитающее")  // больший ID
connection_type = HYPERNYM

Интерпретация требует знания семантики типа
```

### 9.2 Симметрия и асимметрия

**Симметричные связи:**

- Флаг BIDIRECTIONAL установлен
- Эффект одинаков в обоих направлениях
- Примеры: SYNONYM, ASSOCIATION, SIMILARITY

**Асимметричные связи:**

- Флаг BIDIRECTIONAL сброшен
- Имеют направление: token_a → token_b
- Примеры: HYPERNYM (кот → млекопитающее), CAUSE (огонь → тепло)

**Обработка направленности:**

```
При применении силы:
    if BIDIRECTIONAL:
        apply_symmetric_force(token_a, token_b)
    else:
        apply_directed_force(source=token_a, target=token_b)
```

### 9.3 Конфликты и приоритеты

Когда несколько связей влияют на одну пару токенов:

**Разрешение конфликтов:**

```
Приоритет (от высшего к низшему):
    1. Связи с RULE_* типами (connection_type >= 0x90)
    2. Связи с высокой жёсткостью (rigidity > 200)
    3. Связи с флагом PERSISTENT
    4. Связи с высоким activation_count
    5. Связи с флагом REINFORCED
    6. Более новые связи (created_at больше)
```

**Стратегии композиции сил:**

1. **Аддитивная (по умолчанию):**

```
total_force = sum(force_from_each_connection)
```

2. **Доминирующая:**

```
dominant_connection = max(connections, key=lambda c: c.priority)
total_force = force_from(dominant_connection)
```

3. **Взвешенная:**

```
total_force = weighted_sum(connections, weight_function)
```

### 9.4 Взаимодействие с Token

**Синхронизация состояний:**

```
При изменении координат токена:
    - Связи автоматически используют новые координаты
    - Не требуется явное обновление связей
    
При удалении токена:
    - Все связи, ссылающиеся на токен, должны быть удалены или деактивированы
    - Рекомендуется каскадное удаление
```

**Уровни совместимости:**

```
Связь влияет на токен только на уровнях, где:
    1. Связь активна (active_levels)
    2. Токен имеет определённые координаты (coords[L] != None)
    3. Связь не противоречит ограничениям токена
```

### 9.5 Семантические инварианты

**Обязательные условия:**

```
1. token_a_id < token_b_id (канонический порядок)
2. token_a_id > 0 && token_b_id > 0 (валидные ID)
3. token_a_id != token_b_id (нет самосвязей)
4. last_activation >= created_at (временная согласованность)
5. Для RULE_* типов: rigidity >= 230 (≈0.9)
6. Для RULE_* типов: PERSISTENT флаг установлен
```

**Рекомендуемые условия:**

```
1. preferred_distance >= 0.0 (неотрицательное расстояние)
2. |pull_strength| <= 10.0 (разумная сила)
3. Если BIDIRECTIONAL: connection_type в симметричных категориях
4. Если !BIDIRECTIONAL: connection_type в направленных категориях
```

---

## 10. Физическая модель

### 10.1 Механика частиц

Connection реализует модель взаимодействия, аналогичную классической механике:

**Токены как частицы:**

- Масса: определяется полем `weight` в Token
- Позиция: координаты в 8-мерном пространстве
- Скорость: вычисляется как изменение координат за единицу времени

**Связи как силы:**

- Connection генерирует силу между частицами
- Сила зависит от расстояния (подобно пружине)
- Закон Гука: `F = -k × Δx`, где `k` аналогично `rigidity × pull_strength`

### 10.2 Потенциальная энергия

Каждая связь создаёт потенциальную яму:

```
Потенциальная функция:
    U(r) = 0.5 × k × (r - r₀)²
    
где:
    r = current_distance
    r₀ = preferred_distance
    k = rigidity × pull_strength
    
Свойства:
    - Минимум при r = r₀ (равновесие)
    - Параболическая форма (гармонический осциллятор)
    - Жёсткость k определяет кривизну
```

**Модификация для отталкивания:**

```
Если pull_strength < 0:
    U(r) = -0.5 × |k| × (r - r₀)²
    
Потенциал инвертирован, точка r₀ становится максимумом энергии
```

### 10.3 Силовое поле

Градиент потенциала определяет силу:

```
F = -∇U = -dU/dr
  = -k × (r - r₀)
  = k × (r₀ - r)
  = rigidity × pull_strength × (preferred_distance - current_distance)
```

**Векторная форма:**

```
F_vector = F_magnitude × direction
    
где:
    direction = normalize(token_b.position - token_a.position)
    F_magnitude = rigidity × pull_strength × (preferred_distance - |Δr|)
```

### 10.4 Численное интегрирование

**Метод Эйлера (простой):**

```
Шаг обновления:
    force = compute_force(connection, token_a, token_b)
    
    token_a.velocity += (force / token_a.mass) × dt
    token_a.position += token_a.velocity × dt
    
    token_b.velocity -= (force / token_b.mass) × dt  // Третий закон Ньютона
    token_b.position += token_b.velocity × dt
```

**Метод Верле (рекомендуемый):**

```
Более стабильный для колебательных систем:
    
    position_new = 2 × position_current - position_prev + acceleration × dt²
    
где:
    acceleration = force / mass
```

**Затухание (damping):**

```
Для стабилизации системы:
    velocity_new = velocity_old × DAMPING_FACTOR
    
Рекомендуемое DAMPING_FACTOR = 0.95 - 0.99
```

### 10.5 Самоорганизация

**Процесс формирования полей:**

```
Начальное состояние:
    - Токены распределены случайно или равномерно
    - Связи создаются на основе семантики или со-встречаемости
    
Итеративный процесс:
    for iteration in 1..N:
        for each connection:
            compute and apply forces
        
        update token positions
        apply damping
        
        if converged:
            break
    
Результат:
    - Токены с сильными связями группируются (кластеры)
    - Формируются области высокой плотности (поля смыслов)
    - Система достигает низкоэнергетического состояния
```

**Критерий сходимости:**

```
total_kinetic_energy = sum(0.5 × mass × velocity²) for all tokens

if total_kinetic_energy < THRESHOLD:
    system_converged = true
```

**Эмерджентные свойства:**

- Поля смыслов возникают без явного программирования
- Топология определяется семантикой связей
- Иерархии формируются естественно через типы HYPERNYM
- Противоположности (ANTONYM) расходятся в пространстве

### 10.6 Многоуровневая динамика

Каждый из 8 уровней пространства эволюционирует независимо:

```
for level in 0..7:
    if connection.is_active_on_level(level):
        distance = compute_distance(token_a.coords[level], token_b.coords[level])
        force = compute_force(connection, distance)
        apply_force(token_a.coords[level], token_b.coords[level], force)
```

**Кросс-уровневые эффекты:** Хотя уровни эволюционируют независимо, связи могут создавать корреляции:

```
Пример: CAUSE (дождь → мокрая земля)
    active_levels = L1 (Physical) | L7 (Temporal) | L8 (Abstract)
    
    Результат:
        - Токены сближаются в L7 (происходят близко во времени)
        - Токены связываются в L8 (семантическая причинность)
        - Токены могут быть близки в L1 (физическая локация события)
```

---

## 11. Хранение и индексация

### 11.1 Структуры данных

**Основное хранилище:**

```
Primary Storage:
    Type: Hash Map / Dictionary
    Key: (token_a_id, token_b_id)  // Всегда канонический порядок
    Value: Connection
    
    Операции:
        Insert: O(1)
        Lookup: O(1)
        Delete: O(1)
```

**Индексы для быстрого доступа:**

**Индекс по токенам:**

```
Token Index:
    Type: Inverted Index
    Key: token_id
    Value: Set[(token_a_id, token_b_id)]  // Все связи данного токена
    
    Применение:
        - Найти все связи токена: O(k), где k — количество связей
        - Каскадное удаление при удалении токена
```

**Индекс по типам:**

```
Type Index:
    Type: Inverted Index
    Key: connection_type
    Value: Set[(token_a_id, token_b_id)]
    
    Применение:
        - Найти все связи определённого типа: O(m), где m — количество связей типа
        - Статистика по типам
        - Фильтрация при визуализации
```

**Индекс по уровням:**

```
Level Index:
    Type: Inverted Index
    Key: level (0-7)
    Value: Set[(token_a_id, token_b_id)]
    
    Применение:
        - Найти все связи, активные на уровне: O(n), где n — количество связей уровня
        - Оптимизация вычислений (обрабатывать только релевантные связи)
```

**Индекс по временным меткам:**

```
Temporal Index:
    Type: Sorted Set / B-Tree
    Key: last_activation
    Value: (token_a_id, token_b_id)
    
    Применение:
        - Найти устаревшие связи: O(log N + k)
        - Cleanup операции
        - Статистика активности
```

### 11.2 Sparse хранение

**Концепция разреженности:**

```
Теоретическое максимальное количество связей:
    max_connections = n × (n - 1) / 2
    
    Для 50,000 токенов: 1,249,975,000 связей
    Память: 1.25B × 32 bytes = 40 GB
    
Реальное количество (0.01% - 0.1% от максимума):
    actual_connections ≈ 125,000 - 1,250,000
    Память: 4 MB - 40 MB
```

**Материализация связей:**

```
Связь создаётся только когда:
    1. Явно запрошена модулем
    2. Токены со-активировались N раз (threshold)
    3. Расстояние между токенами < threshold
    4. Вычислена высокая семантическая близость
```

**Пороги материализации:**

```
MIN_COACTIVATIONS = 5        // Минимум совместных активаций
MAX_DISTANCE = 2.0           // Максимальное расстояние для автосоздания
MIN_SIMILARITY = 0.7         // Минимальная схожесть (для SIMILARITY типа)
```

### 11.3 Persistence (сохранение на диск)

**Бинарный формат файла:**

```
File Structure:
    [Header: 64 bytes]
        - Magic number: "NGCONN01" (8 bytes)
        - Version: uint32 (4 bytes)
        - Connection count: uint64 (8 bytes)
        - Created timestamp: uint32 (4 bytes)
        - Checksum: uint32 (4 bytes)
        - Reserved: 36 bytes
    
    [Connections: count × 32 bytes]
        - Connection #1: 32 bytes
        - Connection #2: 32 bytes
        - ...
        - Connection #N: 32 bytes
    
    [Footer: 32 bytes]
        - Index offset: uint64 (8 bytes)
        - Index size: uint64 (8 bytes)
        - Reserved: 16 bytes
```

**Стратегии сериализации:**

1. **Full dump (полная выгрузка):**

```
Сохранить все связи подряд
Преимущества: Простота, скорость записи
Недостатки: Долгая загрузка при большом количестве
```

2. **Incremental (инкрементальная):**

```
Сохранять только изменения с последнего dump
Преимущества: Быстрые операции
Недостатки: Требует периодической консолидации
```

3. **Selective (избирательная):**

```
Сохранять только связи с флагом PERSISTENT
Преимущества: Минимальный размер файла
Недостатки: Потеря временных связей
```

### 11.4 Компрессия

**Для уменьшенияразмера файлов:**

**Методы компрессии:**

1. **Словарная компрессия ID:**

```
Если ID токенов имеют общие префиксы:
    - Построить словарь уникальных префиксов
    - Хранить индексы вместо полных ID
    - Экономия: до 50% для похожих ID
```

2. **Delta encoding для timestamp:**

```
Вместо хранения абсолютных timestamp:
    - Сохранить базовый timestamp
    - Для каждой связи хранить delta от базового
    - Использовать меньший тип (uint16 или uint24)
    - Экономия: 50% на timestamp полях
```

3. **Квантование float значений:**

```
Для pull_strength и preferred_distance:
    - Использовать fixed-point вместо float32
    - Например, uint16 с фиксированным масштабом
    - Экономия: 50% на float полях
    - Потеря точности: приемлема для большинства случаев
```

4. **Битовые поля для флагов:**

```
Уже максимально компактно (1 байт на 8 флагов)
Дальнейшая компрессия не требуется
```

5. **Внешняя компрессия:**

```
Применить алгоритм общего назначения к файлу:
    - LZ4: быстрая компрессия/декомпрессия
    - Zstd: хорошее соотношение скорость/степень
    - LZMA: максимальная компрессия, медленнее
    
Экономия: 50-80% в зависимости от алгоритма
```

**Компромиссы:**

```
Без компрессии:
    + Быстрый доступ
    + Простая реализация
    - Большой размер файла

С компрессией:
    + Меньший размер (важно для больших систем)
    - Дополнительная сложность
    - Overhead при загрузке/сохранении
```

### 11.5 Кэширование

**Многоуровневый кэш:**

**L1 Cache (горячие связи):**

```
Size: 1000-10000 связей
Policy: LRU (Least Recently Used)
Content: Часто активируемые связи
Hit rate target: >90%
```

**L2 Cache (активные связи):**

```
Size: 10000-100000 связей
Policy: LFU (Least Frequently Used)
Content: Связи с activation_count > threshold
Hit rate target: >70%
```

**Cold Storage (архив):**

```
Location: Диск
Content: Редко используемые связи
Access: Lazy loading при необходимости
```

**Политика управления кэшем:**

```
При активации связи:
    1. Проверить L1 cache → если есть, использовать
    2. Если нет в L1, проверить L2 → переместить в L1
    3. Если нет в L2, загрузить с диска → добавить в L2
    4. Если L1 переполнен, вытеснить LRU элемент в L2
    5. Если L2 переполнен, вытеснить LFU элемент на диск
```

### 11.6 Параллельный доступ

**Стратегии синхронизации:**

**Read-Write Locks:**

```
Для каждого индекса:
    - Multiple readers OR single writer
    - Преимущества: высокая читающая параллельность
    - Недостатки: writer может блокировать readers
```

**Fine-grained Locking:**

```
Отдельные locks для:
    - Каждого bucket в hash map
    - Каждого уровня в индексах
    
Преимущества: минимальная конкуренция
Недостатки: сложность управления
```

**Lock-free структуры:**

```
Использование atomic операций:
    - Compare-and-swap для обновлений
    - Версионирование для read consistency
    
Преимущества: максимальная параллельность
Недостатки: сложная реализация
```

**Рекомендуемый подход для Rust:**

```
Использовать:
    - Arc<RwLock<HashMap<>>> для основного хранилища
    - DashMap для lock-free concurrent access
    - Atomic операции для счётчиков
```

---

## 12. Жизненный цикл

### 12.1 Создание связи

**Явное создание:**

```
Шаги:
    1. Валидация входных параметров
    2. Нормализация порядка token IDs
    3. Проверка существования токенов
    4. Проверка отсутствия дубликата
    5. Инициализация полей
    6. Добавление в хранилище
    7. Обновление индексов
    
Параметры по умолчанию:
    connection_type = 0x00 (UNDEFINED)
    rigidity = 128 (0.5)
    active_levels = 0xFF (ALL_LEVELS)
    flags = 0x01 (ACTIVE)
    activation_count = 0
    pull_strength = 0.5
    preferred_distance = 1.0
    created_at = current_time
    last_activation = current_time
```

**Автоматическое создание:**

```
Триггеры:
    1. Совместная активация токенов > N раз
    2. Малое расстояние между токенами в пространстве
    3. Высокая семантическая близость
    4. Запрос модуля когнитивной системы
    
Процесс:
    1. Обнаружение триггерного условия
    2. Вычисление начальных параметров на основе статистики
    3. Определение типа связи (эвристически или через ML)
    4. Создание связи с вычисленными параметрами
```

### 12.2 Активация связи

**Процесс активации:**

```
Действия:
    1. Инкремент activation_count
    2. Обновление last_activation = current_time
    3. Установка флага REINFORCED
    4. Сброс флага DECAYING
    5. Опционально: усиление параметров (если MUTABLE)
    6. Опционально: запись в лог активации
    
Побочные эффекты:
    - Повышение приоритета в кэше
    - Перемещение в "горячую" зону хранилища
    - Обновление статистики
```

**Условия активации:**

```
Связь активируется когда:
    1. Оба токена активны в системе
    2. Запрошена явно модулем
    3. Участвует в вычислении сил
    4. Используется в семантическом поиске
```

### 12.3 Эволюция параметров

**Усиление (для MUTABLE связей):**

```
При каждой активации:
    if flags & MUTABLE:
        // Увеличение жёсткости (постепенное укрепление)
        rigidity_new = min(255, rigidity + RIGIDITY_INCREMENT)
        
        // Усиление pull_strength
        if pull_strength > 0:
            pull_strength_new = min(MAX_STRENGTH, pull_strength * 1.01)
        
        // Сжатие preferred_distance для притягивающих связей
        if pull_strength > 0 && preferred_distance > MIN_DISTANCE:
            preferred_distance_new = preferred_distance * 0.99
```

**Затухание (для неактивных связей):**

```
Периодически (например, каждые 100 шагов симуляции):
    for each connection:
        stale_time = current_time - last_activation
        
        if stale_time > DECAY_THRESHOLD && flags & MUTABLE:
            // Уменьшение жёсткости
            rigidity_new = max(0, rigidity - DECAY_AMOUNT)
            
            // Ослабление pull_strength
            pull_strength_new = pull_strength * 0.995
            
            // Установка флага DECAYING
            flags |= DECAYING
            flags &= ~REINFORCED
            
            // Проверка порога удаления
            if rigidity_new < MIN_RIGIDITY_THRESHOLD:
                mark_for_deletion(connection)
```

### 12.4 Удаление связи

**Явное удаление:**

```
Процесс:
    1. Проверка флага PERSISTENT (если установлен → предупреждение)
    2. Удаление из основного хранилища
    3. Удаление из всех индексов
    4. Опционально: запись в лог удалений
    5. Опционально: архивирование перед удалением
```

**Автоматическое удаление (Garbage Collection):**

```
Критерии удаления:
    1. (stale_time > MAX_AGE) AND
    2. (activation_count < MIN_ACTIVATIONS) AND
    3. !(flags & PERSISTENT) AND
    4. (rigidity < MIN_RIGIDITY_THRESHOLD)
    
Процесс cleanup:
    candidates = find_stale_connections()
    
    for connection in candidates:
        if should_delete(connection):
            archive_if_needed(connection)
            delete(connection)
    
    return count_deleted
```

**Каскадное удаление:**

```
При удалении токена:
    token_connections = index_by_token[token_id]
    
    for (a_id, b_id) in token_connections:
        if a_id == token_id || b_id == token_id:
            delete_connection(a_id, b_id)
```

### 12.5 Состояния связи

**Диаграмма состояний:**

```
[CREATED] ──activate──> [ACTIVE/REINFORCED]
    │                         │
    │                         │ (frequent use)
    │                         ▼
    │                   [ACTIVE/STABLE]
    │                         │
    │                         │ (no use)
    │                         ▼
    └────────────────> [DECAYING]
                              │
                              │ (reactivate)
                              ├────────> [ACTIVE/REINFORCED]
                              │
                              │ (threshold exceeded)
                              ▼
                         [DELETED]
```

**Переходы:**

```
CREATED → ACTIVE/REINFORCED:
    Trigger: первая активация
    Action: flags |= ACTIVE | REINFORCED

ACTIVE/REINFORCED → ACTIVE/STABLE:
    Trigger: time > REINFORCEMENT_DURATION
    Action: flags &= ~REINFORCED

ACTIVE/STABLE → DECAYING:
    Trigger: stale_time > DECAY_THRESHOLD
    Action: flags |= DECAYING, flags &= ~ACTIVE

DECAYING → ACTIVE/REINFORCED:
    Trigger: активация
    Action: flags = ACTIVE | REINFORCED, flags &= ~DECAYING

DECAYING → DELETED:
    Trigger: cleanup при превышении порогов
    Action: remove from storage
```

---

## 13. Валидация

### 13.1 Структурная валидация

**Обязательные проверки:**

```
1. ID токенов:
    - token_a_id > 0 && token_b_id > 0
    - token_a_id < token_b_id (канонический порядок)
    - token_a_id != token_b_id (нет самосвязей)
    
2. Существование токенов:
    - token_exists(token_a_id) == true
    - token_exists(token_b_id) == true
    
3. Тип связи:
    - 0 <= connection_type <= 255
    - connection_type определён в CONNECTION_TYPES
    
4. Жёсткость:
    - 0 <= rigidity <= 255
    
5. Уровни:
    - 0x00 <= active_levels <= 0xFF
    - Рекомендуется: active_levels != 0x00 (хотя бы один уровень)
    
6. Флаги:
    - 0x00 <= flags <= 0xFF
    - !(flags & REINFORCED && flags & DECAYING)
    
7. Счётчик:
    - activation_count >= 0
    
8. Временные метки:
    - created_at > 0
    - last_activation >= created_at
    - last_activation <= current_time
    - created_at <= current_time
```

**Проверки согласованности float:**

```
9. pull_strength:
    - !isnan(pull_strength) && !isinf(pull_strength)
    - Рекомендуется: |pull_strength| <= 10.0
    
10. preferred_distance:
    - !isnan(preferred_distance) && !isinf(preferred_distance)
    - preferred_distance >= 0.0
    - Рекомендуется: preferred_distance <= 100.0
```

### 13.2 Семантическая валидация

**Проверки соответствия типу:**

```
Для RULE_* типов (0x90-0x9F):
    - rigidity >= 230 (≈0.9)
    - flags & PERSISTENT
    - Рекомендуется: !flags & MUTABLE
    - Рекомендуется: preferred_distance ≈ 0.0
    
Для SYNONYM (0x01):
    - Рекомендуется: preferred_distance < 0.2
    - Рекомендуется: rigidity > 180 (≈0.7)
    - Рекомендуется: pull_strength > 0
    
Для ANTONYM (0x02):
    - Рекомендуется: preferred_distance > 2.0
    - Рекомендуется: pull_strength < 0 (отталкивание)
    
Для направленных типов:
    - !flags & BIDIRECTIONAL (рекомендуется)
    
Для симметричных типов:
    - flags & BIDIRECTIONAL (рекомендуется)
```

**Проверки активных уровней:**

```
Для физических отношений (SPATIAL_*):
    - active_levels & 0x01 (L1 Physical активен)
    
Для временных отношений (TEMPORAL_*):
    - active_levels & 0x40 (L7 Temporal активен)
    
Для семантических отношений:
    - active_levels & 0x80 (L8 Abstract активен)
```

### 13.3 Статистическая валидация

**Обнаружение аномалий:**

```
1. Необычно высокий activation_count:
    if activation_count > PERCENTILE_99:
        flag_as_anomaly("extremely_high_activations")
    
2. Необычно старая связь без активаций:
    age = current_time - created_at
    if age > 30_DAYS && activation_count < 10:
        flag_as_anomaly("old_unused_connection")
    
3. Экстремальные параметры:
    if |pull_strength| > 5.0:
        flag_as_warning("extreme_pull_strength")
    
    if preferred_distance > 50.0:
        flag_as_warning("extreme_preferred_distance")
    
4. Противоречивые флаги:
    if (flags & PERSISTENT) && (flags & DECAYING):
        flag_as_warning("persistent_but_decaying")
```

### 13.4 Уровни валидации

**Strict (строгая):**

```
Назначение: Production системы
Действия при ошибке: Отклонить операцию, throw error
Применяется: При создании, загрузке, критических операциях
```

**Permissive (допускающая):**

```
Назначение: Разработка, эксперименты
Действия при ошибке: Логировать warning, корректировать значения
Применяется: При отладке, импорте данных
```

**Diagnostic (диагностическая):**

```
Назначение: Анализ существующих данных
Действия при ошибке: Собирать статистику, не прерывать
Применяется: При аудите, профилировании
```

### 13.5 Коррекция ошибок

**Автоматическая коррекция (с логированием):**

```
1. Нарушение канонического порядка:
    if token_a_id > token_b_id:
        swap(token_a_id, token_b_id)
        log_warning("corrected_id_order")
    
2. Временные метки в будущем:
    if created_at > current_time:
        created_at = current_time
        log_warning("corrected_created_at")
    
    if last_activation > current_time:
        last_activation = current_time
        log_warning("corrected_last_activation")
    
3. Некорректные временные метки:
    if last_activation < created_at:
        last_activation = created_at
        log_warning("corrected_activation_order")
    
4. NaN/Inf в float полях:
    if isnan(pull_strength) || isinf(pull_strength):
        pull_strength = 0.5  // default
        log_error("corrected_invalid_pull_strength")
    
    if isnan(preferred_distance) || isinf(preferred_distance):
        preferred_distance = 1.0  // default
        log_error("corrected_invalid_preferred_distance")
    
5. Противоречивые флаги:
    if (flags & REINFORCED) && (flags & DECAYING):
        flags &= ~DECAYING  // Приоритет у REINFORCED
        log_warning("resolved_flag_conflict")
```

---

## 14. Производительность

### 14.1 Оценка сложности операций

**Базовые операции:**

```
Создание связи:
    - Временная сложность: O(1) для вставки + O(k) для обновления индексов
    - Пространственная сложность: O(1) — 32 байта
    - где k — количество индексов (обычно 3-5)
    
Поиск связи по паре ID:
    - Временная сложность: O(1) — hash lookup
    - Кэш hit: O(1)
    - Кэш miss + disk: O(log N) + I/O
    
Поиск всех связей токена:
    - Временная сложность: O(m), где m — количество связей токена
    - Обычно m << N (благодаря sparse)
    
Активация связи:
    - Временная сложность: O(1) — обновление полей
    - Если MUTABLE: +O(1) для вычисления новых параметров
    
Удаление связи:
    - Временная сложность: O(1) для удаления + O(k) для обновления индексов
    
Вычисление силы:
    - Временная сложность: O(1) — арифметические операции
    - Включает: distance calculation, force computation
```

**Массовые операции:**

```
Обновление всех связей (один шаг симуляции):
    - Временная сложность: O(C × L), где:
        - C = количество активных связей
        - L = среднее количество активных уровней на связь
    
    - Типичные значения:
        - C = 10,000 - 1,000,000
        - L = 1-3
        - Итого: 10k - 3M операций
    
Cleanup (удаление устаревших):
    - Временная сложность: O(C), где C = количество связей
    - Оптимизация с temporal index: O(log N + k), где k = количество устаревших
    
Сериализация:
    - Временная сложность: O(C)
    - I/O время: O(C × 32 bytes)
```

### 14.2 Оптимизации памяти

**Память на связь:**

```
Базовая структура: 32 байта
Индексные overhead (указатели): ~24-48 байт (зависит от реализации)
Итого на связь в памяти: ~56-80 байт

Для 1,000,000 связей:
    - Основные данные: 32 MB
    - С индексами: ~56-80 MB
    - Приемлемо для современных систем
```

**Стратегии экономии:**

```
1. Lazy loading:
    - Хранить в памяти только активные связи
    - Загружать с диска по требованию
    - Экономия: до 90% памяти для редко используемых связей
    
2. Compression в cold storage:
    - Сжимать неактивные связи
    - Экономия: 50-80% дискового пространства
    
3. Shared strings для метаданных:
    - Если есть текстовые метаданные, использовать string interning
    
4. Битовые поля уже максимально компактны
```

**Memory pooling:**

```
Преаллокация блоков по 1000 связей:
    - Уменьшение фрагментации
    - Улучшение cache locality
    - Быстрая аллокация/деаллокация
```

### 14.3 Оптимизации вычислений

**Spatial partitioning:**

```
Для уменьшения количества вычислений:
    - Разделить пространство на regions/cells
    - Вычислять силы только для связей в близких регионах
    - Игнорировать связи между далёкими токенами
    
Алгоритмы:
    - Quadtree/Octree для L1 (Physical)
    - Grid-based partitioning для других уровней
    
Экономия: 50-90% вычислений в зависимости от плотности
```

**Batch processing:**

```
Обработка связей пакетами:
    - SIMD операции для вычисления сил
    - Векторизация distance calculations
    - GPU acceleration для больших систем
    
Ускорение: 4x-16x с SIMD, 100x+ с GPU
```

**Level-selective computation:**

```
Не все уровни требуют обновления каждый шаг:
    - L1 (Physical): каждый шаг
    - L7 (Temporal): каждые 10 шагов
    - L8 (Abstract): каждые 100 шагов
    
Экономия: 30-50% вычислений
```

**Early termination:**

```
При вычислении сил:
    if current_distance ≈ preferred_distance (within epsilon):
        force = 0
        skip_computation()
    
    if |force_magnitude| < FORCE_THRESHOLD:
        force = 0
        skip_application()
```

### 14.4 Параллелизация

**Thread-safety:**

```
Стратегии для Rust:
    - Arc<RwLock<>> для shared state
    - Channels для communication между threads
    - Rayon для data parallelism
```

**Параллельное вычисление сил:**

```
Независимые связи могут обрабатываться параллельно:
    - Partition connections по token_id ranges
    - Каждый thread обрабатывает свой partition
    - Синхронизация только при применении сил к токенам
    
Ускорение: линейное до N cores (теоретически)
Реальное: 60-80% от линейного (из-за синхронизации)
```

**Lock-free индексы:**

```
Использование concurrent hash maps:
    - DashMap в Rust
    - Минимальная конкуренция
    - Масштабируемость до десятков threads
```

### 14.5 Benchmarking

**Ключевые метрики:**

```
Throughput:
    - Connections created per second
    - Connections activated per second
    - Force computations per second
    
Latency:
    - Time to create connection
    - Time to find connection
    - Time to compute force
    - Time to update position
    
Memory:
    - Bytes per connection
    - Total memory usage
    - Cache hit rate
    
I/O:
    - Disk read/write speed
    - Serialization/deserialization time
```

**Целевые показатели:**

```
Для системы с 50,000 токенов и 500,000 связей:
    
    Creation: > 100,000 conn/sec
    Lookup: > 1,000,000 lookups/sec
    Activation: > 500,000 activations/sec
    Force computation: > 10,000,000 forces/sec
    Simulation step: < 100ms для всех связей
    
    Memory: < 100 MB total
    Cache hit rate: > 90%
    
    Serialization: < 1 second
    Deserialization: < 2 seconds
```

---

## 15. Совместимость

### 15.1 Совместимость с Token v2.0

**Зависимости:**

```
Connection требует:
    - Token v2.0 или выше
    - Наличие координат в 8 пространствах
    - Соответствие масштабов координат
    
Token требования:
    - ID уникальны и валидны
    - Координаты инициализированы для используемых уровней
```

**Соответствие уровней:**

```
Connection.active_levels должны соответствовать Token.coordinates:
    - Если bit N установлен в active_levels
    - То Token.coordinates[N] должны быть определены (не None/127)
    
Если несоответствие:
    - Warning: связь не может влиять на уровень
    - Поведение: игнорировать этот уровень при вычислениях
```

### 15.2 Версионирование

**Текущая версия: 1.0.0**

**Схема версионирования:**

```
MAJOR.MINOR.PATCH

MAJOR: Несовместимые изменения структуры (изменение размера, порядка полей)
MINOR: Обратно совместимые добавления (новые типы, флаги)
PATCH: Исправления ошибок, уточнения спецификации
```

**Обратная совместимость:**

```
v1.0.x совместима с v1.0.0:
    - Размер структуры неизменен (32 байта)
    - Порядок полей неизменен
    - Семантика существующих полей неизменена
    
v1.1.x может добавить:
    - Новые connection_type значения
    - Новые интерпретации флагов (используя зарезервированные биты)
    - Новые рекомендации по параметрам
    
v2.0.0 может изменить:
    - Размер структуры
    - Порядок полей
    - Типы данных
```

**Проверка версии:**

```
При загрузке файла:
    version = read_version_from_header()
    
    if version.major != CURRENT_MAJOR:
        error("Incompatible version")
    
    if version.minor > CURRENT_MINOR:
        warning("File from newer version, some features may not work")
    
    if version.minor < CURRENT_MINOR:
        info("File from older version, will upgrade")
```

### 15.3 Миграция данных

**Миграция v1.0 → v1.1 (гипотетическая):**

```
Если v1.1 добавляет новые поля, используя зарезервированное пространство:
    - Прочитать v1.0 структуру
    - Инициализировать новые поля значениями по умолчанию
    - Сохранить в формате v1.1
```

**Миграция v1.x → v2.0 (breaking changes):**

```
Потребуется явная конверсия:
    old_connections = load_v1_format(file)
    
    new_connections = []
    for old_conn in old_connections:
        new_conn = convert_v1_to_v2(old_conn)
        new_connections.append(new_conn)
    
    save_v2_format(new_connections, new_file)
```

### 15.4 Interoperability

**JSON представление:**

```
Для интеграции с внешними системами:

{
  "version": "1.0.0",
  "connection": {
    "token_a_id": 42,
    "token_b_id": 100,
    "connection_type": {
      "code": 1,
      "name": "SYNONYM"
    },
    "rigidity": 0.9,
    "active_levels": ["L8"],
    "flags": {
      "active": true,
      "bidirectional": true,
      "persistent": false,
      "mutable": true
    },
    "dynamics": {
      "pull_strength": 0.8,
      "preferred_distance": 0.05,
      "activation_count": 1523
    },
    "timestamps": {
      "created_at": "2025-01-15T10:30:00Z",
      "last_activation": "2025-10-21T14:25:00Z"
    }
  }
}
```

**Protocol Buffers:**

```
Для эффективной передачи по сети:

message Connection {
  uint32 token_a_id = 1;
  uint32 token_b_id = 2;
  uint32 connection_type = 3;
  uint32 rigidity = 4;
  uint32 active_levels = 5;
  uint32 flags = 6;
  uint32 activation_count = 7;
  float pull_strength = 8;
  float preferred_distance = 9;
  uint32 created_at
```= 10; uint32 last_activation = 11; }

```

**SQL схема:**
```

Для хранения в реляционных БД:

CREATE TABLE connections ( token_a_id INTEGER NOT NULL, token_b_id INTEGER NOT NULL, connection_type SMALLINT NOT NULL, rigidity SMALLINT NOT NULL, active_levels SMALLINT NOT NULL, flags SMALLINT NOT NULL, activation_count INTEGER NOT NULL, pull_strength REAL NOT NULL, preferred_distance REAL NOT NULL, created_at INTEGER NOT NULL, last_activation INTEGER NOT NULL,

```
PRIMARY KEY (token_a_id, token_b_id),
CHECK (token_a_id < token_b_id),
CHECK (token_a_id > 0 AND token_b_id > 0),
CHECK (rigidity BETWEEN 0 AND 255),
CHECK (active_levels BETWEEN 0 AND 255),
CHECK (flags BETWEEN 0 AND 255),
CHECK (activation_count >= 0),
CHECK (preferred_distance >= 0.0),
CHECK (last_activation >= created_at)
```

);

CREATE INDEX idx_token_a ON connections(token_a_id); CREATE INDEX idx_token_b ON connections(token_b_id); CREATE INDEX idx_type ON connections(connection_type); CREATE INDEX idx_last_activation ON connections(last_activation);

```

---

## 16. Формат сериализации

### 16.1 Бинарный формат файла

**Общая структура файла:**
```

╔═══════════════════════════════════════════════════════════╗ ║ FILE HEADER (64 bytes) ║ ╠═══════════════════════════════════════════════════════════╣ ║ CONNECTION DATA (N × 32 bytes) ║ ║ ┌─────────────────────────────────────────────────────┐ ║ ║ │ Connection #1 (32 bytes) │ ║ ║ ├─────────────────────────────────────────────────────┤ ║ ║ │ Connection #2 (32 bytes) │ ║ ║ ├─────────────────────────────────────────────────────┤ ║ ║ │ ... │ ║ ║ ├─────────────────────────────────────────────────────┤ ║ ║ │ Connection #N (32 bytes) │ ║ ║ └─────────────────────────────────────────────────────┘ ║ ╠═══════════════════════════════════════════════════════════╣ ║ OPTIONAL INDEX (variable) ║ ╠═══════════════════════════════════════════════════════════╣ ║ FILE FOOTER (32 bytes) ║ ╚═══════════════════════════════════════════════════════════╝

```

### 16.2 File Header

**Детальная структура (64 bytes):**
```

Offset Size Type Field Description

---

0 8 char[8] magic "NGCONN01" (ASCII) 8 2 uint16 version_major Major version (1) 10 2 uint16 version_minor Minor version (0) 12 2 uint16 version_patch Patch version (0) 14 2 uint16 endianness 0x0102 = little-endian 16 8 uint64 connection_count Number of connections 24 4 uint32 created_timestamp File creation time 28 4 uint32 modified_timestamp Last modification time 32 4 uint32 checksum_type 0=none, 1=CRC32, 2=SHA256 36 4 uint32 checksum_value Checksum (if type=1) 40 4 uint32 flags File-level flags 44 4 uint32 compression_type 0=none, 1=LZ4, 2=Zstd 48 8 uint64 index_offset Offset to index section (0=none) 56 8 uint64 reserved Reserved for future use

---

TOTAL: 64 bytes

```

**File-level flags:**
```

Bit 0: SORTED_BY_ID - Connections sorted by (token_a_id, token_b_id) Bit 1: INCLUDES_INDEX - Index section present Bit 2: COMPRESSED - Data is compressed Bit 3: ENCRYPTED - Data is encrypted Bit 4-31: Reserved

```

### 16.3 Connection Data Section

**Формат:**
```

Последовательность Connection структур (32 bytes каждая) Порядок: Определяется флагом SORTED_BY_ID в header Компрессия: Если COMPRESSED флаг установлен, вся секция сжата

```

**Чтение:**
```

Алгоритм: 1. Прочитать header 2. Проверить magic number и версию 3. Если COMPRESSED, распаковать секцию данных 4. Для каждой из connection_count связей: - Прочитать 32 байта - Десериализовать в структуру Connection - Валидировать - Добавить в хранилище

```

### 16.4 Optional Index Section

**Назначение:** Ускорение поиска без полной загрузки файла

**Структура:**
```

Index Section: [Index Header: 32 bytes] - Index type: uint32 (1=token, 2=type, 3=combined) - Entry count: uint64 - Entry size: uint16 - Reserved: 18 bytes

```
[Index Entries: N × entry_size]
    Token Index Entry:
        - token_id: uint32
        - offset: uint64 (byte offset in file)
        - count: uint32 (number of connections)
    
    Type Index Entry:
        - connection_type: uint8
        - offset: uint64
        - count: uint32
```

```

**Использование:**
```

Быстрый поиск всех связей токена: 1. Загрузить index section 2. Найти token_id в индексе 3. Seek к offset 4. Прочитать count связей

Экономия: Избежание полной десериализации файла

```

### 16.5 File Footer

**Структура (32 bytes):**
```

Offset Size Type Field Description

---

0 8 char[8] magic_end "CONNEND\0" 8 8 uint64 file_size Total file size in bytes 16 4 uint32 data_checksum Checksum всех connections 20 4 uint32 validation_flags Validation status 24 8 uint64 reserved Reserved

---

TOTAL: 32 bytes

```

**Validation flags:**
```

Bit 0: DATA_VALID - All connections passed validation Bit 1: INDEX_VALID - Index is consistent with data Bit 2: CHECKSUM_VALID - Checksums match Bit 3-31: Reserved

```

### 16.6 Примеры форматов

**Минимальный файл (1 connection):**
```

Size: 64 (header) + 32 (connection) + 32 (footer) = 128 bytes

[Header: 64 bytes] magic: "NGCONN01" version: 1.0.0 count: 1 ...

[Connection: 32 bytes] token_a_id: 42 token_b_id: 100 ...

[Footer: 32 bytes] magic_end: "CONNEND\0" ...

```

**Файл с индексом:**
```

Size: 64 (header) + N×32 (connections) + index_size + 32 (footer)

[Header: includes index_offset] [Connections: N × 32 bytes] [Index Section: variable] [Footer]

```

**Сжатый файл:**
```

[Header: flags |= COMPRESSED] [Compressed Data: connection_count × 32 bytes, compressed] [Footer]

Note: Index не сжимается для быстрого доступа

```

### 16.7 Streaming формат

**Для больших файлов:**
```

Chunked format: [File Header] [Chunk 1: N connections] [Chunk 2: N connections] ... [Chunk M: N connections] [Footer]

Преимущества: - Можно читать/писать по частям - Меньше памяти при обработке - Возможность параллельной обработки чанков

```

### 16.8 Incremental updates

**Формат для инкрементальных обновлений:**
```

Append-only log: [Base File: полная выгрузка] [Delta 1: изменения с момента base] [Delta 2: изменения с момента delta 1] ...

Delta format: [Delta Header] [Operations] - INSERT: full connection (32 bytes) - UPDATE: id pair + changed fields - DELETE: id pair only [Delta Footer]

Consolidation: Периодически объединять deltas в новый base file

```

### 16.9 Cross-platform considerations

**Endianness:**
```

Стандарт: Little-endian Проверка: Поле endianness в header = 0x0102

При чтении на big-endian системе: if header.endianness != native_endianness: apply_byte_swapping()

```

**Alignment:**
```

Структура Connection выровнена по 4 байтам Никакого padding не требуется Portable между архитектурами

```

**Float representation:**
```

Стандарт: IEEE 754 single precision Универсально поддерживается Проверка при загрузке: if !is_ieee754_compatible(): error("Platform not supported")

```

### 16.10 Error handling

**Ошибки при чтении:**
```

1. Invalid magic number: Action: Reject file, это не Connection file
    
2. Unsupported version: Action: Попытаться миграцию или отклонить
    
3. Checksum mismatch: Action: Warning или error в зависимости от политики Опция: Попытаться восстановить валидные связи
    
4. Truncated file: Action: Загрузить частично, пометить как incomplete
    
5. Invalid connection data: Action: Пропустить невалидную связь, продолжить Log: Записать детали для анализа
    
6. Out of memory: Action: Использовать streaming mode
    

```

**Стратегии восстановления:**
```

Partial load: - Загрузить все валидные связи - Пропустить поврежденные - Вернуть список ошибок

Backup restore: - Проверить наличие backup файла - Загрузить из backup - Применить deltas если возможно

Manual repair: - Экспортировать в human-readable формат - Позволить ручное редактирование - Re-import после исправления

````

---

## Приложения

### A. Константы и пороговые значения

**Рекомендуемые системные константы:**
```rust
// Пороги активации
const MIN_COACTIVATIONS: u32 = 5;
const ACTIVATION_THRESHOLD: u32 = 10;

// Временные пороги (секунды)
const THRESHOLD_FRESH: u32 = 60;           // 1 минута
const THRESHOLD_RECENT: u32 = 300;         // 5 минут
const THRESHOLD_ACTIVE: u32 = 3600;        // 1 час
const THRESHOLD_STALE: u32 = 86400;        // 1 день
const THRESHOLD_OLD: u32 = 604800;         // 1 неделя
const DECAY_THRESHOLD: u32 = 3600;         // 1 час для затухания

// Пороги важности
const MIN_ACTIVATIONS_EPHEMERAL: u32 = 5;
const MIN_ACTIVATIONS_TEMPORARY: u32 = 50;
const MIN_ACTIVATIONS_STABLE: u32 = 500;
const MIN_ACTIVATIONS_PERMANENT: u32 = 5000;

// Физические параметры
const MAX_FORCE: f32 = 1.0;
const MIN_DISTANCE: f32 = 0.01;
const MAX_DISTANCE: f32 = 100.0;
const DAMPING_FACTOR: f32 = 0.98;
const DEFAULT_DT: f32 = 0.01;

// Параметры эволюции
const RIGIDITY_INCREMENT: u8 = 1;
const DECAY_AMOUNT: u8 = 1;
const AMPLIFICATION_FACTOR: f32 = 1.01;
const COMPRESSION_FACTOR: f32 = 0.99;
const DECAY_FACTOR: f32 = 0.995;
const MIN_RIGIDITY_THRESHOLD: u8 = 10;

// Лимиты
const MAX_PULL_STRENGTH: f32 = 10.0;
const MAX_PREFERRED_DISTANCE: f32 = 100.0;
````

### B. Глоссарий терминов

**Connection (Связь)**

- Сущность, представляющая отношение между двумя токенами

**Token (Токен)**

- Базовая единица информации в NeuroGraph OS

**Rigidity (Жёсткость)**

- Сопротивление связи к изменению расстояния между токенами

**Pull Strength (Сила притяжения)**

- Интенсивность силового взаимодействия

**Preferred Distance (Предпочитаемое расстояние)**

- Целевое расстояние, которое связь пытается поддерживать

**Active Levels (Активные уровни)**

- Пространства, в которых связь оказывает влияние

**Semantic Field (Семантическое поле)**

- Область высокой плотности токенов с сильными связями

**Sparse (Разреженный)**

- Характеристика хранения, где существует малая доля от возможных связей

**Canonical Order (Канонический порядок)**

- Соглашение `token_a_id < token_b_id` для избежания дублирования

**Activation (Активация)**

- Использование связи, инкремент счётчика активаций

**Reinforcement (Усиление)**

- Процесс укрепления связи при частом использовании

**Decay (Затухание)**

- Процесс ослабления связи при отсутствии использования

**Materialization (Материализация)**

- Создание физической записи связи в памяти/на диске

### C. Ссылки

**Связанные спецификации:**

- Token v2.0 Specification
- NeuroGraph OS Architecture Overview
- Coordinate System Specification

**Стандарты:**

- IEEE 754 (Floating Point)
- Unix Time (POSIX timestamp)
- UTF-8 (для строковых данных)
- Little-endian byte order

**Теоретические основы:**

- Particle Systems
- Force-directed Graph Drawing
- Self-organizing Maps
- Semantic Networks

### D. История изменений

**Version 1.0 (2025-10-21)**

- Первый официальный релиз спецификации
- 32-байтная структура данных
- 8-уровневая система активности
- Поддержка 256 типов связей
- Физическая модель силового взаимодействия
- Sparse хранение и индексация
- Механизмы эволюции параметров

**Future Considerations (для v2.0)**

- Дополнительные типы связей
- Расширенные метрики качества
- Оптимизации для GPU
- Distributed storage support

---

## Заключение

Connection Specification v1.0 определяет компактную, эффективную и семантически богатую структуру для представления связей между токенами в NeuroGraph OS.

**Ключевые достижения спецификации:**

✅ **Компактность** — 32 байта на связь  
✅ **Физическая модель** — силовое взаимодействие для самоорганизации  
✅ **Типизация** — 256 типов связей для богатой семантики  
✅ **Многоуровневость** — независимое действие на 8 пространствах  
✅ **Эволюция** — динамические параметры с усилением и затуханием  
✅ **Sparse хранение** — эффективное использование памяти  
✅ **Производительность** — оптимизированные структуры данных и индексы

**Connection как фундамент:**

Связи являются механизмом, через который:

- Токены самоорганизуются в семантические поля
- Знание структурируется в многомерном пространстве
- Различные когнитивные модули координируют своё поведение
- Система эволюционирует от использования

**Практическое применение:**

Данная спецификация предоставляет полную техническую основу для реализации на любом системном языке (Rust, C++, C) и интеграции с NeuroGraph OS Token v2.0.

---

**Версия документа:** 1.0 
**Дата:** 2025-10-21  
**Статус:** Official Specification  
**Авторы:** NeuroGraph OS Team  
**Лицензия:** Определяется проектом NeuroGraph OS

**Контакты для вопросов:**  
Данная спецификация является живым документом. Предложения по улучшению приветствуются.

---

**END OF SPECIFICATION**