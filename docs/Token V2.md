
# Спецификация токена v2 NeuroGraph OS

## Концепция токена

**Токен** — это базовая единица информации в NeuroGraph OS, представляющая дискретный элемент данных в многомерном пространстве состояний. Токен инкапсулирует позиционную информацию, метаданные и состояние объекта системы.

## Философия дизайна

#### Токен спроектирован как:

- **Атомарная единица** - неделимый элемент системы
- **Самодостаточная структура** - содержит всю необходимую информацию о себе
- **Компактное представление** - оптимизированное бинарное кодирование
- **Многомерная сущность** - существует одновременно в 8 пространствах
- **Временная единица** - имеет жизненный цикл и историю

## Бинарная структура (64 байта)
#### Детальная структура полей

| **Поле**           | **Смещение (Байты)** | **Размер (Байты)** | **Тип**                          | **Интерпретация / Примечание**                                                                                                   |
| ------------------ | -------------------- | ------------------ | -------------------------------- | -------------------------------------------------------------------------------------------------------------------------------- |
| **coordinates**    | 0-47                 | **48**             | $8 \times 3 \times \mathbf{i16}$ | 24 координаты (X, Y, Z для 8 объектов). Используют **фиксированную точку** (масштаб 100 или 1000) для хранения дробных значений. |
| **ID**             | 48-51                | **4**              | $\mathbf{u32}$                   | Уникальный идентификатор (до $\approx 4.29$ миллиардов).                                                                         |
| **Flags**          | 52-53                | **2**              | $\mathbf{u16}$                   | 16 битов для хранения логических состояний/свойств.                                                                              |
| **weight**         | 54-57                | **4**              | $\mathbf{f32}$                   | Весовой коэффициент, сила или значимость. Хранится как 32-битное число с плавающей точкой (IEEE 754).                            |
| **field_radius**   | 58                   | **1**              | $\mathbf{uint8}$                 | Радиус. Использует **фиксированную точку** (вероятно, масштаб 100) для кодирования $0.0-2.55$.                                   |
| **field_strength** | 59                   | **1**              | $\mathbf{uint8}$                 | Сила. Использует **фиксированную точку** (вероятно, деление на 255) для кодирования $0.0-1.0$.                                   |
| **timestamp**      | 60-63                | **4**              | $\mathbf{u32}$                   | Время создания/изменения в формате **Unix timestamp**.                                                                           |
## Поля токена

### 1. COORDINATES (48 байт) - Многомерное позиционирование

Токен существует одновременно в 8 различных пространствах состояний:

```python
COORDINATE_SPACES = {
    0: "L1_PHYSICAL",    # Физическое пространство
    1: "L2_SENSORY",     # Сенсорное пространство  
    2: "L3_MOTOR",       # Моторное пространство
    3: "L4_EMOTIONAL",   # Эмоциональное пространство
    4: "L5_COGNITIVE",   # Когнитивное пространство
    5: "L6_SOCIAL",      # Социальное пространство
    6: "L7_TEMPORAL",    # Темпоральное пространство
    7: "L8_ABSTRACT"     # Абстрактное пространство
}
```


#### Кодирование координат

- **Тип данных**: signed int16 (-32,768 to +32,767)
- **Масштабирование**: координаты умножаются на 100 для точности до 0.01
- **Диапазон значений**: -327.67 to +327.67 в каждой оси
- **Отсутствие данных**: значение 127 (0x7F) означает отсутствие координаты
- **Формат**: (X, Y, Z) для каждого уровня

```python
def encode_coordinate(value: float) -> int:
    """Кодирует float координату в int16"""
    if value is None:
        return 127  # Специальное значение "отсутствует"
    return max(-32767, min(32767, int(value * 100)))

def decode_coordinate(encoded: int) -> Optional[float]:
    """Декодирует int16 координату в float"""
    if encoded == 127:
        return None
    return encoded / 100.0
```

#### Семантика пространств
#### 1. Проработка 8 семантических пространств (L1-L8)

Ключевым ограничением здесь является формат i16 (знаковое 16-битное целое), которое дает диапазон от -32,768 до +32,767. Вы упомянули "масштаб 100", что дает реальный диапазон от ≈−327.68 до +327.67.

Этот масштаб отлично подходит для одних пространств (как L1), но плох для других (как L4, где нужен диапазон -1.0 до +1.0).

**Предложение:** Масштаб (множитель) должен быть _концептуально разным_ для разных пространств, даже если он не хранится в токене. Система, читающая токен, должна _знать_, что L1-координаты нужно делить на 100, а L4-координаты — на 10,000.

Вот моя проработанная версия L1-L8 с учетом этого:

#### L1: PHYSICAL (Физическое)

- **X:** Позиция (Восток/Запад)
    
- **Y:** Позиция (Север/Юг)
    
- **Z:** Высота (Над уровнем)
    
- **Единицы:** Метры
    
- **Кодирование (`i16`):**
    
    - **Масштаб:** 100
        
    - **Интерпретация:** `i16` значение `10000` = `100.0` метров.
        
    - **Диапазон:** от `-327.68` до `+327.67` метров. Подходит для локального позиционирования (комната, здание, небольшой квартал).
        

#### L2: SENSORY (Сенсорное)

Ваш вариант смешивал зрение и слух. Лучше сфокусировать пространство на одной модальности или сделать оси более абстрактными. Предлагаю второй вариант:

- **X:** Салиентность (Заметность)
    
- **Y:** Валентность (Привлекательность/Отвращение)
    
- **Z:** Новизна (Степень изменения/неожиданности)
    
- **Единицы:** Нормализованный индекс (безразмерный)
    
- **Кодирование (`i16`):**
    
    - **Масштаб:** 10000
        
    - **Интерпретация:** `i16` значение `10000` = `1.0`.
        
    - **Диапазон:**
        
        - X (Салиентность): `0` до `10000` → `0.0` (незаметно) до `1.0` (очень заметно).
            
        - Y (Валентность): `-10000` до `+10000` → `-1.0` (негативно) до `+1.0` (позитивно).
            
        - Z (Новизна): `0` до `10000` → `0.0` (привычно) до `1.0` (абсолютно ново).
            

#### L3: MOTOR (Моторное)

Ваш вариант отличный. Уточним кодирование.

- **X:** Линейная скорость (вдоль вектора "вперед")
    
- **Y:** Линейное ускорение (вдоль вектора "вперед")
    
- **Z:** Угловая скорость (вокруг оси Y, "рысканье")
    
- **Единицы:** м/с, м/с², рад/с
    
- **Кодирование (`i16`):**
    
    - **Масштаб:** 1000 (дает лучший диапазон, чем 100)
        
    - **Интерпретация:** `i16` значение `1000` = `1.0` (м/с, м/с² или рад/с).
        
    - **Диапазон:** от `-32.768` до `+32.767` в соответствующих единицах. (Диапазон ≈±32 м/с для скорости и ≈±32 рад/с (5 об/сек) для вращения — более чем достаточно).
        

#### L4: EMOTIONAL (Эмоциональное)

Ваш вариант (модель VAD) — стандарт де-факто. Он идеален.

- **X:** Valence (Валентность: Удовольствие ↔ Неудовольствие)
    
- **Y:** Arousal (Возбуждение: Активность ↔ Пассивность)
    
- **Z:** Dominance (Доминирование: Контроль ↔ Подчинение)
    
- **Единицы:** Нормализованный индекс
    
- **Кодирование (`i16`):**
    
    - **Масштаб:** 10000
        
    - **Интерпретация:** `i16` значение `10000` = `1.0`.
        
    - **Диапазон:** `-10000` до `+10000` → `-1.0` до `+1.0` для всех трех осей.
        

#### L5: COGNITIVE (Когнитивное)

Ваши оси хорошие, но "абстракция" и "сложность" могут коррелировать. Предлагаю разделить "нагрузку" и "содержание".

- **X:** Когнитивная нагрузка (Mental Load)
    
- **Y:** Уровень абстракции
    
- **Z:** Уверенность / Определенность
    
- **Единицы:** Нормализованный индекс
    
- **Кодирование (`i16`):**
    
    - **Масштаб:** 10000
        
    - **Интерпретация:** `i16` значение `10000` = `1.0`.
        
    - **Диапазон:**
        
        - X (Нагрузка): `0` до `10000` → `0.0` (нет) до `1.0` (макс).
            
        - Y (Абстракция): `0` до `10000` → `0.0` (конкретный объект) до `1.0` (философская концепция).
            
        - Z (Уверенность): `0` до `10000` → `0.0` (полная неуверенность) до `1.0` (абсолютная уверенность).
            

#### L6: SOCIAL (Социальное)

Ваш вариант хорош. Немного уточним "принадлежность".

- **X:** Социальная дистанция (Близость/Интимность)
    
- **Y:** Иерархический статус (относительно наблюдателя)
    
- **Z:** Принадлежность (In-group vs Out-group)
    
- **Единицы:** Нормализованный индекс
    
- **Кодирование (`i16`):**
    
    - **Масштаб:** 10000
        
    - **Интерпретация:** `i16` значение `10000` = `1.0`.
        
    - **Диапазон:** `-10000` до `+10000` → `-1.0` до `+1.0` для всех осей.
        
        - X: `-1.0` (враждебный/далекий) до `+1.0` (близкий/интимный).
            
        - Y: `-1.0` (подчиненный) до `+1.0` (доминантный).
            
        - Z: `-1.0` (чужой/out-group) до `+1.0` (свой/in-group).
            

#### L7: TEMPORAL (Темпоральное)

Ваш вариант отличный. Локализацию лучше всего делать относительно `timestamp` самого токена.

- **X:** Временное смещение (Offset)
    
- **Y:** Длительность (Duration)
    
- **Z:** Периодичность (Frequency)
    
- **Единицы:** Секунды (X, Y), Герцы (Z)
    
- **Кодирование (`i16`):**
    
    - **Масштаб:** 100 (для секунд), 1000 (для Герц)
        
    - **Интерпретация:**
        
        - X (Смещение): `i16` / 100.0. Диапазон ≈±327 сек (относительно `timestamp`).
            
        - Y (Длительность): `i16` / 100.0. Диапазон `0` до `327` сек (используем только положительные значения `0`..`32767`).
            
        - Z (Частота): `i16` / 1000.0. Диапазон `0` до `32.7` Гц (используем только `0`..`32767`).
            

#### L8: ABSTRACT (Абстрактное)

Ваш вариант превосходен для семантического анализа.

- **X:** Семантическая близость (к опорной концепции)
    
- **Y:** Каузальная связь (причинность)
    
- **Z:** Логическая модальность (необходимость/возможность)
    
- **Единицы:** Нормализованный индекс
    
- **Кодирование (`i16`):**
    
    - **Масштаб:** 10000
        
    - **Интерпретация:** `i16` значение `10000` = `1.0`.
        
    - **Диапазон:** `-10000` до `+10000` → `-1.0` до `+1.0`.
        
        - X: `-1.0` (антоним) до `+1.0` (синоним/идентичность). `0` = не связано.
            
        - Y: `-1.0` (ингибирует/предотвращает) до `+1.0` (вызывает/порождает). `0` = нет связи.
            
        - Z: `-1.0` (невозможно/противоречие) до `+1.0` (логически необходимо). `0` = возможно/случайно.
### 2. ID (4 байта) - Уникальный идентификатор

```python
# Структура ID (32 бита)
# Биты 0-23:  Локальный ID (16,777,216 токенов)
# Биты 24-27: Тип сущности (16 типов)
# Биты 28-31: Домен/область (16 доменов)

ENTITY_TYPES = {
    0x0: "UNDEFINED",     # Неопределенный тип
    0x1: "OBJECT",        # Физический объект
    0x2: "EVENT",         # Событие
    0x3: "STATE",         # Состояние
    0x4: "PROCESS",       # Процесс
    0x5: "CONCEPT",       # Концепт/идея
    0x6: "RELATION",      # Отношение
    0x7: "PATTERN",       # Паттерн
    0x8: "RULE",          # Правило
    0x9: "GOAL",          # Цель
    0xA: "MEMORY",        # Память
    0xB: "SENSOR",        # Сенсор
    0xC: "ACTUATOR",      # Актуатор
    0xD: "CONTROLLER",    # Контроллер
    0xE: "BUFFER",        # Буфер
    0xF: "RESERVED"       # Зарезервировано
}

def extract_entity_type(token_id: int) -> int:
    return (token_id >> 24) & 0xF

def extract_domain(token_id: int) -> int:
    return (token_id >> 28) & 0xF

def extract_local_id(token_id: int) -> int:
    return token_id & 0xFFFFFF

def create_id(local_id: int, entity_type: int, domain: int) -> int:
    return (domain << 28) | (entity_type << 24) | (local_id & 0xFFFFFF)
```

### 3. FLAGS (2 байта) 
#### Полная 16-битная карта флагов (u16) для описания состояния токена:

```python 
#--- Системные флаги (Биты 0-7) ---
# Управляют состоянием, хранением и обработкой самого токена

FLAG_ACTIVE       = 0x0001  # (Бит 0) 1: Токен активен
FLAG_PERSISTENT   = 0x0002  # (Бит 1) 1: Токен должен быть сохранен
FLAG_MUTABLE      = 0x0004  # (Бит 2) 1: Токен может изменяться
FLAG_SYNCHRONIZED = 0x0008  # (Бит 3) 1: Синхронизирован
FLAG_COMPRESSED   = 0x0010  # (Бит 4) 1: Данные, на которые ссылается токен, сжаты
FLAG_ENCRYPTED    = 0x0020  # (Бит 5) 1: Данные, на которые ссылается токен, зашифрованы
FLAG_DIRTY        = 0x0040  # (Бит 6) 1: Токен был изменен, но не сохранен
FLAG_LOCKED       = 0x0080  # (Бит 7) 1: Токен заблокирован

# --- Семантические флаги: Тип Сущности (Биты 8-11) ---
# Определяют, что именно представляет токен (16 возможных типов)

ENTITY_TYPE_MASK  = 0x0F00  # Маска для выделения битов 8-11 (0000 1111 0000 0000)

TYPE_UNDEFINED    = 0x0000  # (0000) Неопределенный тип
TYPE_OBJECT       = 0x0100  # (0001) Физический объект
TYPE_EVENT        = 0x0200  # (0010) Событие
TYPE_STATE        = 0x0300  # (0011) Состояние
TYPE_PROCESS      = 0x0400  # (0100) Процесс
TYPE_CONCEPT      = 0x0500  # (0101) Концепт/идея
TYPE_RELATION     = 0x0600  # (0110) Отношение
TYPE_PATTERN      = 0x0700  # (0111) Паттерн
TYPE_RULE         = 0x0800  # (1000) Правило
TYPE_GOAL         = 0x0900  # (1001) Цель
TYPE_MEMORY       = 0x0A00  # (1010) Память
TYPE_SENSOR       = 0x0B00  # (1011) Сенсор
TYPE_ACTUATOR     = 0x0C00  # (1100) Актуатор
TYPE_CONTROLLER   = 0x0D00  # (1101) Контроллер
TYPE_BUFFER       = 0x0E00  # (1110) Буфер
TYPE_RESERVED     = 0x0F00  # (1111) Зарезервировано

# --- Пользовательские флаги (Биты 12-15) ---
# Зарезервированы для специфических нужд приложения

FLAG_USER_1       = 0x1000  # (Бит 12) Пользовательский флаг 1
FLAG_USER_2       = 0x2000  # (Бит 13) Пользовательский флаг 2
FLAG_USER_3       = 0x4000  # (Бит 14) Пользовательский флаг 3
FLAG_USER_4       = 0x8000  # (Бит 15) Пользовательский флаг 4
```

```python
# Инициализация флагов (например, токен - активный процесс)
flags = FLAG_ACTIVE | TYPE_PROCESS

# Проверка типа
entity_type = flags & ENTITY_TYPE_MASK
if entity_type == TYPE_PROCESS:
    print("Это токен процесса.")

# Проверка флага
if flags & FLAG_ACTIVE:
    print("Токен активен.")

# Изменение типа
flags = (flags & ~ENTITY_TYPE_MASK) | TYPE_EVENT
print(f"Новый тип: 0x{((flags & ENTITY_TYPE_MASK) >> 8):X}") # Выведет: Новый тип: 0x2
```
### 4. WEIGHT (4 байт) - Интенсивность и важность

IEEE 754 float32 значение, представляющее:

```python
class TokenWeight:
    def __init__(self, weight: float = 0.0):
        self.weight = max(0.0, min(1.0, weight))
    
    @property
    def intensity(self) -> float:
        """Интенсивность токена (0.0 - 1.0)"""
        return self.weight
    
    @property
    def priority(self) -> int:
        """Приоритет токена (0 - 255)"""
        return int(self.weight * 255)
        
    @property
    def energy_level(self) -> float:
        """Энергетический уровень"""
        return self.weight ** 2  # Квадратичная зависимость
    
    def decay(self, factor: float = 0.99) -> 'TokenWeight':
        """Затухание веса со временем"""
        return TokenWeight(self.weight * factor)
    
    def amplify(self, factor: float = 1.1) -> 'TokenWeight':
        """Усиление веса"""
        return TokenWeight(min(1.0, self.weight * factor))
```

**Семантика веса:**

- `0.0` - неактивный/отсутствующий токен
- `0.1-0.3` - слабая активация
- `0.3-0.7` - умеренная активация
- `0.7-0.9` - сильная активация
- `0.9-1.0` - максимальная активация


### 5. field_radius (Радиус Влияния)

|**Параметр**|**Значение**|**Описание**|
|---|---|---|
|**Название**|`field_radius` (R)|Радиус пространственного или семантического влияния токена.|
|**Смещение (Offset)**|58|Поле занимает 1 байт, начиная с 58-го байта.|
|**Размер (Size)**|1 Байт|Максимально компактное хранение данных.|
|**Тип**|$\mathbf{uint8}$|**Беззнаковое 8-битное целое число** (диапазон $0 \text{ до } 255$).|
|**Метод**|Фиксированная точка, **Масштаб 100**|Целое значение делится на 100 для получения дробного.|
|**Диапазон (Ед.)**|$0.00 \text{ до } 2.55$|**Минимальный** радиус $0.00$ ($0/100$), **Максимальный** радиус $2.55$ ($255/100$).|
|**Ед. измерения**|$\text{м/у.е.}$|Метры (для физических пространств) или условные единицы (для абстрактных пространств).|
|**Кодирование**|$\mathbf{R} = \frac{\text{целое значение } (0-255)}{100}$|Например, сохраненное значение **50** интерпретируется как $\mathbf{0.50}$.|

---

### 6. field_strength (Интенсивность Силы)

|**Параметр**|**Значение**|**Описание**|
|---|---|---|
|**Название**|`field_strength` (S)|Интенсивность силы или нормированная значимость влияния токена.|
|**Смещение (Offset)**|59|Поле занимает 1 байт, начиная с 59-го байта.|
|**Размер (Size)**|1 Байт|Максимально компактное хранение данных.|
|**Тип**|$\mathbf{uint8}$|**Беззнаковое 8-битное целое число** (диапазон $0 \text{ до } 255$).|
|**Метод**|Фиксированная точка, **Масштаб 255**|Целое значение нормируется относительно максимального значения $\mathbf{255}$.|
|**Диапазон (Ед.)**|$0.000 \text{ до } 1.000$|**Минимальная** сила $0.0$ ($0/255$), **Максимальная** сила $1.0$ ($255/255$).|
|**Ед. измерения**|У.е. (Нормировано)|Представляет вероятность, долю или нормированную значимость.|
|**Кодирование**|$\mathbf{S} = \frac{\text{целое значение } (0-255)}{255}$|Например, сохраненное значение **128** интерпретируется как $\mathbf{0.5019...}$ (т.е. $\approx 50\%$ силы).|

### 7. TIMESTAMP (4 байта) - Временная информация

Unix timestamp (секунды с 1 января 1970):

```python
class TokenTimestamp:
    def __init__(self, timestamp: Optional[int] = None):
        self.timestamp = timestamp or int(time.time())
    
    @property
    def datetime(self) -> datetime:
        return datetime.fromtimestamp(self.timestamp)
    
    @property
    def age_seconds(self) -> int:
        return int(time.time()) - self.timestamp
    
    @property
    def age_minutes(self) -> float:
        return self.age_seconds / 60.0
    
    def is_recent(self, seconds: int = 60) -> bool:
        return self.age_seconds <= seconds
    
    def is_stale(self, seconds: int = 3600) -> bool:
        return self.age_seconds > seconds
```

### ps. RESERVED - Расширения

#### Возможные типы расширений

```python

# Возможные типы расширений
EXTENSION_TYPES = {
    0x0: "NONE",           # Нет расширения
    0x1: "PARENT_REF",     # Ссылка на родителя
    0x2: "CLUSTER_ID",     # ID кластера
    0x3: "PRIORITY_HINT",  # Подсказка приоритета
    0x4: "COLOR_TAG",      # Цветовая метка
    0x5: "SIZE_HINT",      # Подсказка размера
    0x6: "LIFECYCLE",      # Жизненный цикл
    0x7: "ACCESS_COUNT",   # Счетчик обращений
    0x8: "ERROR_CODE",     # Код ошибки
    0x9: "BATCH_ID",       # ID пакета
    0xA: "VERSION",        # Версия токена
    0xB: "CHECKSUM",       # Контрольная сумма
    0xC: "COMPRESSION",    # Информация о сжатии
    0xD: "SECURITY",       # Уровень безопасности
    0xE: "CUSTOM_1",       # Пользовательское 1
    0xF: "CUSTOM_2"        # Пользовательское 2
}
```



Эта спецификация описывает токен как самостоятельную сущность со всеми его внутренними характеристиками и возможностями.
